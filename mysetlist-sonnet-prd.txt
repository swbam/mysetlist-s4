\# MySetlist Concert Setlist App \- Project Overview & Architecture

\#\# Table of Contents  
1\. \[Project Overview\](\#project-overview)  
2\. \[Next-Forge Foundation\](\#next-forge-foundation)  
3\. \[Technology Stack\](\#technology-stack)  
4\. \[Application Architecture\](\#application-architecture)  
5\. \[Feature Set Overview\](\#feature-set-overview)  
6\. \[Development Phases\](\#development-phases)  
7\. \[Team Handoff Strategy\](\#team-handoff-strategy)

\#\# Project Overview

MySetlist is a comprehensive concert setlist platform that allows users to discover, track, and share live music experiences. Built on the Next-Forge starter template, it leverages modern web technologies to create a seamless experience for music fans to explore concert history, vote on setlists, and connect with the live music community.

\#\#\# Core Vision  
\- \*\*Discover\*\*: Find upcoming shows, venues, and artist histories  
\- \*\*Track\*\*: Follow favorite artists and get notified of new shows  
\- \*\*Share\*\*: Contribute setlists and vote on accuracy  
\- \*\*Connect\*\*: Build a community around live music experiences

\#\#\# Target Users  
\- \*\*Music Fans\*\*: Discover new shows and track favorite artists  
\- \*\*Concert Goers\*\*: Contribute and verify setlist information  
\- \*\*Industry Professionals\*\*: Access comprehensive show data  
\- \*\*Venue Operators\*\*: Manage venue information and show listings

\#\# Next-Forge Foundation

\#\#\# Why Next-Forge  
Next-Forge provides a production-ready foundation with enterprise-grade patterns:

\`\`\`  
next-forge structure:  
â”œâ”€â”€ apps/  
â”‚   â””â”€â”€ web/                 \# Main Next.js application  
â”œâ”€â”€ packages/  
â”‚   â”œâ”€â”€ auth/               \# Authentication package  
â”‚   â”œâ”€â”€ database/           \# Database package (Drizzle \+ Supabase)  
â”‚   â”œâ”€â”€ email/              \# Email package (Resend)  
â”‚   â”œâ”€â”€ ui/                 \# Shared UI components  
â”‚   â””â”€â”€ utils/              \# Shared utilities  
â”œâ”€â”€ tooling/  
â”‚   â”œâ”€â”€ eslint/             \# ESLint configuration  
â”‚   â”œâ”€â”€ prettier/           \# Prettier configuration  
â”‚   â””â”€â”€ typescript/         \# TypeScript configuration  
â””â”€â”€ infrastructure/         \# Deployment configurations  
\`\`\`

\#\#\# Key Benefits  
\- \*\*Monorepo Structure\*\*: Organized codebase with shared packages  
\- \*\*Type Safety\*\*: End-to-end TypeScript with strict configurations  
\- \*\*Authentication Ready\*\*: Built-in auth patterns with multiple providers  
\- \*\*Database Integration\*\*: Drizzle ORM with migration support  
\- \*\*Component Library\*\*: Shadcn/ui components pre-configured  
\- \*\*Deployment Ready\*\*: Vercel-optimized with CI/CD

\#\# Technology Stack

\#\#\# Core Framework (from Next-Forge)  
\- \*\*Next.js 14\*\*: App Router with Server Components  
\- \*\*React 18\*\*: Latest React features and patterns  
\- \*\*TypeScript\*\*: Strict type checking throughout  
\- \*\*Tailwind CSS\*\*: Utility-first styling  
\- \*\*Shadcn/ui\*\*: Component library foundation

\#\#\# Database & Backend  
\- \*\*Supabase\*\*: PostgreSQL database with real-time features  
\- \*\*Drizzle ORM\*\*: Type-safe database queries  
\- \*\*Row Level Security\*\*: Built-in data protection  
\- \*\*PostGIS\*\*: Location-based queries for venues

\#\#\# Authentication (Modified from Next-Forge)  
\- \*\*Supabase Auth\*\*: Replace Next-Forge auth with Supabase  
\- \*\*Spotify OAuth\*\*: Music streaming integration  
\- \*\*Email/Password\*\*: Traditional authentication  
\- \*\*Social Logins\*\*: Google, Apple integration via Supabase

\#\#\# External APIs  
\- \*\*Spotify API\*\*: Artist data, popularity metrics  
\- \*\*Ticketmaster API\*\*: Venue and show information  
\- \*\*Setlist.fm API\*\*: Historical setlist data  
\- \*\*Location Services\*\*: To be implemented in future versions

\#\#\# Deployment & Infrastructure  
\- \*\*Vercel\*\*: Frontend hosting and serverless functions  
\- \*\*Supabase\*\*: Database and authentication hosting  
\- \*\*Upstash\*\*: Redis for caching and rate limiting  
\- \*\*Resend\*\*: Email delivery service

\#\# Application Architecture

\#\#\# Monorepo Structure (Modified Next-Forge)

\`\`\`  
MySetlist-nextfor/  
â”œâ”€â”€ apps/  
â”‚   â””â”€â”€ web/                           \# Main Next.js application  
â”‚       â”œâ”€â”€ app/                       \# App Router structure  
â”‚       â”‚   â”œâ”€â”€ (auth)/               \# Authentication routes  
â”‚       â”‚   â”œâ”€â”€ (dashboard)/          \# User dashboard  
â”‚       â”‚   â”œâ”€â”€ artists/              \# Artist pages  
â”‚       â”‚   â”œâ”€â”€ shows/                \# Show pages  
â”‚       â”‚   â”œâ”€â”€ venues/               \# Venue pages  
â”‚       â”‚   â”œâ”€â”€ setlists/             \# Setlist pages  
â”‚       â”‚   â””â”€â”€ api/                  \# API routes  
â”‚       â”œâ”€â”€ components/               \# App-specific components  
â”‚       â”œâ”€â”€ hooks/                    \# Custom React hooks  
â”‚       â””â”€â”€ lib/                      \# App utilities  
â”œâ”€â”€ packages/  
â”‚   â”œâ”€â”€ auth/                         \# Supabase authentication  
â”‚   â”œâ”€â”€ database/                     \# Drizzle \+ Supabase schemas  
â”‚   â”œâ”€â”€ email/                        \# Email templates and sending  
â”‚   â”œâ”€â”€ external-apis/                \# Third-party API integrations  
â”‚   â”œâ”€â”€ ui/                           \# Shared UI components  
â”‚   â””â”€â”€ utils/                        \# Shared utilities  
â””â”€â”€ tooling/                          \# Development tools  
\`\`\`

\#\#\# Data Flow Architecture

\`\`\`  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚                    Next.js App Router                        â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  Route Handlers    â”‚  Server Components  â”‚  Client Componentsâ”‚  
â”‚  â”œâ”€â”€ API Routes   â”‚  â”œâ”€â”€ Show Pages     â”‚  â”œâ”€â”€ Interactive  â”‚  
â”‚  â”œâ”€â”€ Webhooks     â”‚  â”œâ”€â”€ Artist Pages   â”‚  â”‚   Forms        â”‚  
â”‚  â””â”€â”€ Auth         â”‚  â””â”€â”€ Search Results â”‚  â””â”€â”€ Vote System  â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚                    Shared Packages                           â”‚  
â”‚  â”œâ”€â”€ @repo/auth   â”œâ”€â”€ @repo/database   â”œâ”€â”€ @repo/ui         â”‚  
â”‚  â”œâ”€â”€ @repo/email  â””â”€â”€ @repo/external-apis                   â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  Supabase          â”‚  External APIs     â”‚  Services         â”‚  
â”‚  â”œâ”€â”€ PostgreSQL   â”‚  â”œâ”€â”€ Spotify       â”‚  â”œâ”€â”€ Vercel       â”‚  
â”‚  â”œâ”€â”€ Auth         â”‚  â”œâ”€â”€ Ticketmaster  â”‚  â”œâ”€â”€ Upstash      â”‚  
â”‚  â””â”€â”€ Real-time    â”‚  â””â”€â”€ Setlist.fm    â”‚  â””â”€â”€ Resend       â”‚  
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  
\`\`\`

\#\# Feature Set Overview

\#\#\# Core Features  
1\. \*\*User Management\*\*  
   \- Supabase authentication with Spotify integration  
   \- User profiles with music preferences  
   \- Following system for artists and users

2\. \*\*Artist Discovery\*\*  
   \- Comprehensive artist profiles with Spotify integration  
   \- Show history and upcoming events  
   \- Real-time popularity metrics

3\. \*\*Show & Venue Management\*\*  
   \- Detailed show information with setlists  
   \- Venue profiles with location mapping  
   \- Historical show data and statistics

4\. \*\*Setlist System\*\*  
   \- Community-driven setlist creation  
   \- Voting system for accuracy verification  
   \- Song metadata integration

5\. \*\*Search & Discovery\*\*  
   \- Full-text search across artists, shows, venues  
   \- Location-based venue discovery  
   \- Trending and recommendation systems

\#\#\# Advanced Features  
\- \*\*Real-time Updates\*\*: Live setlist updates during shows  
\- \*\*Analytics Dashboard\*\*: User engagement and platform metrics  
- **Web Application**: Online-only responsive web experience
\- \*\*Social Features\*\*: Comments, sharing, user interactions

\#\# Development Phases

\#\#\# Phase 1: Foundation Setup (Week 1-2)  
\- Set up Next-Forge monorepo structure  
\- Configure Supabase database and authentication  
\- Implement core database schema with Drizzle  
\- Set up basic UI components and layouts

\#\#\# Phase 2: Core Features (Week 3-6)  
\- User authentication and profile management  
\- Artist and venue CRUD operations  
\- Basic search functionality  
\- Show and setlist management

\#\#\# Phase 3: Advanced Features (Week 7-10)  
\- External API integrations (Spotify, Ticketmaster)  
\- Real-time updates and notifications  
\- Advanced search and filtering  
- Mobile responsiveness and modern web features

\#\#\# Phase 4: Polish & Deploy (Week 11-12)  
\- Performance optimization  
\- Security hardening  
\- Testing and quality assurance  
\- Production deployment and monitoring

\#\# Team Handoff Strategy

\#\#\# Developer Onboarding  
1\. \*\*Repository Setup\*\*  
   \- Clone next-forge template  
   \- Configure environment variables  
   \- Set up local development environment

2\. \*\*Architecture Understanding\*\*  
   \- Review monorepo structure and packages  
   \- Understand data flow and API patterns  
   \- Familiarize with component library

3\. \*\*Development Workflow\*\*  
   \- Feature branch development  
   \- Package-based development approach  
   \- Testing and quality assurance processes

\#\#\# Key Implementation Notes  
\- \*\*Start with Next-Forge\*\*: Use the existing structure as foundation  
\- \*\*Supabase Integration\*\*: Replace default auth with Supabase Auth  
\- \*\*Package Isolation\*\*: Keep features modular using the package system  
\- \*\*Type Safety\*\*: Maintain strict TypeScript throughout  
\- \*\*Performance First\*\*: Optimize for speed and user experience

\#\#\# Success Metrics  
\- \*\*User Engagement\*\*: Active users, session duration  
\- \*\*Content Quality\*\*: Setlist accuracy, user contributions  
\- \*\*Performance\*\*: Page load times, search response times  
\- \*\*Growth\*\*: User acquisition, content creation rates

This overview provides the foundation for building MySetlist using Next-Forge. The following documentation files will detail specific implementation aspects including database schema, component architecture, API integrations, and deployment strategies.

\# MySetlist \- Database Schema and Models with Next-Forge

\#\# Table of Contents  
1\. \[Database Architecture Overview\](\#database-architecture-overview)  
2\. \[Next-Forge Database Package Structure\](\#next-forge-database-package-structure)  
3\. \[Supabase Integration\](\#supabase-integration)  
4\. \[Core Schema Implementation\](\#core-schema-implementation)  
5\. \[Database Package Setup\](\#database-package-setup)  
6\. \[Migration Strategy\](\#migration-strategy)  
7\. \[Real-time Features\](\#real-time-features)  
8\. \[Performance Optimization\](\#performance-optimization)

\#\# Database Architecture Overview

MySetlist leverages Next-Forge's database package structure with Supabase as the backend, combining Drizzle ORM for type-safe queries with PostgreSQL's advanced features.

\#\#\# Technology Stack  
\- \*\*Supabase\*\*: Hosted PostgreSQL with extensions  
\- \*\*Drizzle ORM\*\*: Type-safe database access layer  
\- \*\*PostgreSQL 15\*\*: Primary database with extensions  
\- \*\*PostGIS\*\*: Geospatial queries for venue locations  
\- \*\*Row Level Security\*\*: Built-in data protection

\#\#\# Database Extensions  
\`\`\`sql  
\-- Enable required extensions  
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";  
CREATE EXTENSION IF NOT EXISTS "postgis";  
CREATE EXTENSION IF NOT EXISTS "pg\_trgm";  
CREATE EXTENSION IF NOT EXISTS "unaccent";  
\`\`\`

\#\# Next-Forge Database Package Structure

\#\#\# Package Organization  
\`\`\`  
packages/database/  
â”œâ”€â”€ src/  
â”‚   â”œâ”€â”€ schema/              \# Drizzle schema definitions  
â”‚   â”‚   â”œâ”€â”€ users.ts        \# User-related schemas  
â”‚   â”‚   â”œâ”€â”€ artists.ts      \# Artist and music data  
â”‚   â”‚   â”œâ”€â”€ venues.ts       \# Venue and location data  
â”‚   â”‚   â”œâ”€â”€ shows.ts        \# Show and event data  
â”‚   â”‚   â”œâ”€â”€ setlists.ts     \# Setlist and song data  
â”‚   â”‚   â”œâ”€â”€ analytics.ts    \# Analytics and metrics  
â”‚   â”‚   â”œâ”€â”€ relations.ts    \# Schema relationships  
â”‚   â”‚   â””â”€â”€ index.ts        \# Schema exports  
â”‚   â”œâ”€â”€ queries/            \# Prepared queries  
â”‚   â”‚   â”œâ”€â”€ users.ts        \# User queries  
â”‚   â”‚   â”œâ”€â”€ artists.ts      \# Artist queries  
â”‚   â”‚   â”œâ”€â”€ shows.ts        \# Show queries  
â”‚   â”‚   â””â”€â”€ index.ts        \# Query exports  
â”‚   â”œâ”€â”€ types/              \# Generated and custom types  
â”‚   â”‚   â”œâ”€â”€ database.ts     \# Database types  
â”‚   â”‚   â””â”€â”€ index.ts        \# Type exports  
â”‚   â”œâ”€â”€ migrations/         \# SQL migration files  
â”‚   â”œâ”€â”€ client.ts           \# Database client setup  
â”‚   â”œâ”€â”€ constants.ts        \# Database constants  
â”‚   â””â”€â”€ index.ts            \# Package exports  
â”œâ”€â”€ drizzle.config.ts       \# Drizzle configuration  
â”œâ”€â”€ package.json            \# Package dependencies  
â””â”€â”€ tsconfig.json          \# TypeScript configuration  
\`\`\`

\#\# Supabase Integration

\#\#\# Environment Configuration  
\`\`\`typescript  
// packages/database/src/client.ts  
import { drizzle } from 'drizzle-orm/postgres-js';  
import postgres from 'postgres';  
import \* as schema from './schema';

const connectionString \= process.env.DATABASE\_URL\!;

// For migrations  
export const migrationClient \= postgres(connectionString, { max: 1 });

// For queries  
const queryClient \= postgres(connectionString);  
export const db \= drizzle(queryClient, { schema });

export type Database \= typeof db;  
\`\`\`

\#\#\# Supabase Client Configuration  
\`\`\`typescript  
// packages/database/src/supabase.ts  
import { createClient } from '@supabase/supabase-js';

const supabaseUrl \= process.env.NEXT\_PUBLIC\_SUPABASE\_URL\!;  
const supabaseKey \= process.env.NEXT\_PUBLIC\_SUPABASE\_ANON\_KEY\!;

export const supabase \= createClient(supabaseUrl, supabaseKey);

// For server-side operations  
export const supabaseAdmin \= createClient(  
  supabaseUrl,  
  process.env.SUPABASE\_SERVICE\_ROLE\_KEY\!  
);  
\`\`\`

\#\# Core Schema Implementation

\#\#\# Users Schema  
\`\`\`typescript  
// packages/database/src/schema/users.ts  
import {   
  pgTable,   
  uuid,   
  text,   
  timestamp,   
  boolean,   
  pgEnum   
} from 'drizzle-orm/pg-core';

export const userRoleEnum \= pgEnum('user\_role', \[  
  'user',   
  'moderator',   
  'admin'  
\]);

export const users \= pgTable('users', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  email: text('email').notNull().unique(),  
  displayName: text('display\_name'),  
  avatarUrl: text('avatar\_url'),  
  spotifyId: text('spotify\_id').unique(),  
  spotifyRefreshToken: text('spotify\_refresh\_token'),  
  role: userRoleEnum('role').default('user').notNull(),  
  emailVerified: timestamp('email\_verified'),  
  lastLoginAt: timestamp('last\_login\_at'),  
  preferences: text('preferences'), // JSON string for user preferences  
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
  deletedAt: timestamp('deleted\_at'),  
});

export const userProfiles \= pgTable('user\_profiles', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  userId: uuid('user\_id').references(() \=\> users.id).notNull(),  
  bio: text('bio'),  
  location: text('location'),  
  website: text('website'),  
  favoriteGenres: text('favorite\_genres'), // JSON array  
  concertCount: integer('concert\_count').default(0),  
  isPublic: boolean('is\_public').default(false),  
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
});  
\`\`\`

\#\#\# Artists Schema  
\`\`\`typescript  
// packages/database/src/schema/artists.ts  
import {   
  pgTable,   
  uuid,   
  text,   
  integer,   
  boolean,   
  timestamp,   
  doublePrecision   
} from 'drizzle-orm/pg-core';

export const artists \= pgTable('artists', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  spotifyId: text('spotify\_id').unique(),  
  name: text('name').notNull(),  
  slug: text('slug').unique().notNull(),  
  imageUrl: text('image\_url'),  
  smallImageUrl: text('small\_image\_url'),  
  genres: text('genres'), // JSON array  
  popularity: integer('popularity').default(0),  
  followers: integer('followers').default(0),  
  monthlyListeners: integer('monthly\_listeners'),  
  verified: boolean('verified').default(false),  
  bio: text('bio'),  
  externalUrls: text('external\_urls'), // JSON object  
  lastSyncedAt: timestamp('last\_synced\_at'),  
  trendingScore: doublePrecision('trending\_score').default(0),  
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
});

export const artistStats \= pgTable('artist\_stats', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  artistId: uuid('artist\_id').references(() \=\> artists.id).notNull(),  
  totalShows: integer('total\_shows').default(0),  
  totalSetlists: integer('total\_setlists').default(0),  
  avgSetlistLength: doublePrecision('avg\_setlist\_length'),  
  mostPlayedSong: text('most\_played\_song'),  
  lastShowDate: timestamp('last\_show\_date'),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
});  
\`\`\`

\#\#\# Venues Schema  
\`\`\`typescript  
// packages/database/src/schema/venues.ts  
import {   
  pgTable,   
  uuid,   
  text,   
  integer,   
  doublePrecision,   
  timestamp   
} from 'drizzle-orm/pg-core';

export const venues \= pgTable('venues', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  name: text('name').notNull(),  
  slug: text('slug').unique().notNull(),  
  address: text('address'),  
  city: text('city').notNull(),  
  state: text('state'),  
  country: text('country').notNull(),  
  postalCode: text('postal\_code'),  
  latitude: doublePrecision('latitude'),  
  longitude: doublePrecision('longitude'),  
  timezone: text('timezone').notNull(),  
  capacity: integer('capacity'),  
  venueType: text('venue\_type'), // arena, theater, club, etc.  
  phoneNumber: text('phone\_number'),  
  website: text('website'),  
  imageUrl: text('image\_url'),  
  description: text('description'),  
  amenities: text('amenities'), // JSON array  
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
});  
\`\`\`

\#\#\# Shows Schema  
\`\`\`typescript  
// packages/database/src/schema/shows.ts  
import {   
  pgTable,   
  uuid,   
  text,   
  date,   
  time,   
  integer,   
  boolean,   
  timestamp,   
  doublePrecision,   
  pgEnum   
} from 'drizzle-orm/pg-core';

export const showStatusEnum \= pgEnum('show\_status', \[  
  'upcoming',   
  'ongoing',   
  'completed',   
  'cancelled'  
\]);

export const shows \= pgTable('shows', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  headlinerArtistId: uuid('headliner\_artist\_id').references(() \=\> artists.id).notNull(),  
  venueId: uuid('venue\_id').references(() \=\> venues.id),  
  name: text('name').notNull(),  
  slug: text('slug').unique().notNull(),  
  date: date('date').notNull(),  
  startTime: time('start\_time'),  
  doorsTime: time('doors\_time'),  
  status: showStatusEnum('status').default('upcoming').notNull(),  
  description: text('description'),  
  ticketUrl: text('ticket\_url'),  
  minPrice: integer('min\_price'),  
  maxPrice: integer('max\_price'),  
  currency: text('currency').default('USD'),  
    
  // Analytics fields  
  viewCount: integer('view\_count').default(0),  
  attendeeCount: integer('attendee\_count').default(0),  
  setlistCount: integer('setlist\_count').default(0),  
  voteCount: integer('vote\_count').default(0),  
  trendingScore: doublePrecision('trending\_score').default(0),  
    
  // Featured/promoted content  
  isFeatured: boolean('is\_featured').default(false),  
  isVerified: boolean('is\_verified').default(false),  
    
  // External integrations  
  ticketmasterId: text('ticketmaster\_id'),  
  setlistFmId: text('setlistfm\_id'),  
    
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
});

export const showArtists \= pgTable('show\_artists', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  showId: uuid('show\_id').references(() \=\> shows.id).notNull(),  
  artistId: uuid('artist\_id').references(() \=\> artists.id).notNull(),  
  orderIndex: integer('order\_index').notNull(), // 0 \= headliner  
  setLength: integer('set\_length'), // minutes  
  isHeadliner: boolean('is\_headliner').default(false),  
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
});  
\`\`\`

\#\#\# Songs and Setlists Schema  
\`\`\`typescript  
// packages/database/src/schema/setlists.ts  
import {   
  pgTable,   
  uuid,   
  text,   
  integer,   
  boolean,   
  timestamp,   
  date,   
  pgEnum,  
  unique   
} from 'drizzle-orm/pg-core';

export const songs \= pgTable('songs', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  spotifyId: text('spotify\_id').unique(),  
  title: text('title').notNull(),  
  artist: text('artist').notNull(), // Primary artist name  
  album: text('album'),  
  albumArtUrl: text('album\_art\_url'),  
  releaseDate: date('release\_date'),  
  durationMs: integer('duration\_ms'),  
  popularity: integer('popularity').default(0),  
  previewUrl: text('preview\_url'),  
  isExplicit: boolean('is\_explicit').default(false),  
  isPlayable: boolean('is\_playable').default(true),  
  acousticness: text('acousticness'), // Spotify audio features  
  danceability: text('danceability'),  
  energy: text('energy'),  
  valence: text('valence'),  
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
});

export const setlistTypeEnum \= pgEnum('setlist\_type', \[  
  'predicted',   
  'actual'  
\]);

export const setlists \= pgTable('setlists', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  showId: uuid('show\_id').references(() \=\> shows.id).notNull(),  
  artistId: uuid('artist\_id').references(() \=\> artists.id).notNull(),  
  type: setlistTypeEnum('type').notNull(),  
  name: text('name').default('Main Set'),  
  orderIndex: integer('order\_index').default(0),  
  isLocked: boolean('is\_locked').default(false),  
  totalVotes: integer('total\_votes').default(0),  
  accuracyScore: integer('accuracy\_score').default(0), // 0-100  
    
  // Import tracking  
  importedFrom: text('imported\_from'), // 'setlist.fm', 'manual', 'api'  
  externalId: text('external\_id'),  
  importedAt: timestamp('imported\_at'),  
    
  createdBy: uuid('created\_by').references(() \=\> users.id),  
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
});

export const setlistSongs \= pgTable('setlist\_songs', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  setlistId: uuid('setlist\_id').references(() \=\> setlists.id).notNull(),  
  songId: uuid('song\_id').references(() \=\> songs.id).notNull(),  
  position: integer('position').notNull(),  
  notes: text('notes'), // "acoustic", "cover", "new song", etc.  
  isPlayed: boolean('is\_played'), // For actual setlists  
  playTime: timestamp('play\_time'), // When song was played  
    
  // Vote aggregations (denormalized for performance)  
  upvotes: integer('upvotes').default(0),  
  downvotes: integer('downvotes').default(0),  
  netVotes: integer('net\_votes').default(0),  
    
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
}, (table) \=\> ({  
  uniqueSetlistPosition: unique().on(table.setlistId, table.position),  
}));

export const voteTypeEnum \= pgEnum('vote\_type', \['up', 'down'\]);

export const votes \= pgTable('votes', {  
  id: uuid('id').primaryKey().defaultRandom(),  
  userId: uuid('user\_id').references(() \=\> users.id).notNull(),  
  setlistSongId: uuid('setlist\_song\_id').references(() \=\> setlistSongs.id).notNull(),  
  voteType: voteTypeEnum('vote\_type').notNull(),  
  createdAt: timestamp('created\_at').defaultNow().notNull(),  
  updatedAt: timestamp('updated\_at').defaultNow().notNull(),  
}, (table) \=\> ({  
  uniqueUserVote: unique().on(table.userId, table.setlistSongId),  
}));  
\`\`\`

\#\# Database Package Setup

\#\#\# Package Configuration  
\`\`\`json  
// packages/database/package.json  
{  
  "name": "@repo/database",  
  "version": "0.1.0",  
  "private": true,  
  "main": "./src/index.ts",  
  "types": "./src/index.ts",  
  "scripts": {  
    "generate": "drizzle-kit generate",  
    "migrate": "drizzle-kit migrate",  
    "push": "drizzle-kit push",  
    "studio": "drizzle-kit studio",  
    "seed": "tsx src/seed.ts"  
  },  
  "dependencies": {  
    "@supabase/supabase-js": "^2.38.0",  
    "drizzle-orm": "^0.29.0",  
    "postgres": "^3.4.0"  
  },  
  "devDependencies": {  
    "drizzle-kit": "^0.20.0",  
    "tsx": "^4.0.0"  
  }  
}  
\`\`\`

\#\#\# Drizzle Configuration  
\`\`\`typescript  
// packages/database/drizzle.config.ts  
import type { Config } from 'drizzle-kit';

export default {  
  schema: './src/schema/index.ts',  
  out: './migrations',  
  driver: 'pg',  
  dbCredentials: {  
    connectionString: process.env.DATABASE\_URL\!,  
  },  
  verbose: true,  
  strict: true,  
} satisfies Config;  
\`\`\`

\#\#\# Schema Relations  
\`\`\`typescript  
// packages/database/src/schema/relations.ts  
import { relations } from 'drizzle-orm';  
import {  
  users,  
  artists,  
  venues,  
  shows,  
  setlists,  
  songs,  
  setlistSongs,  
  votes,  
} from '.';

export const usersRelations \= relations(users, ({ many, one }) \=\> ({  
  votes: many(votes),  
  createdSetlists: many(setlists),  
  profile: one(userProfiles, {  
    fields: \[users.id\],  
    references: \[userProfiles.userId\],  
  }),  
}));

export const artistsRelations \= relations(artists, ({ many, one }) \=\> ({  
  shows: many(shows),  
  setlists: many(setlists),  
  stats: one(artistStats, {  
    fields: \[artists.id\],  
    references: \[artistStats.artistId\],  
  }),  
}));

export const showsRelations \= relations(shows, ({ many, one }) \=\> ({  
  headlinerArtist: one(artists, {  
    fields: \[shows.headlinerArtistId\],  
    references: \[artists.id\],  
  }),  
  venue: one(venues, {  
    fields: \[shows.venueId\],  
    references: \[venues.id\],  
  }),  
  setlists: many(setlists),  
  supportingArtists: many(showArtists),  
}));

export const setlistsRelations \= relations(setlists, ({ many, one }) \=\> ({  
  show: one(shows, {  
    fields: \[setlists.showId\],  
    references: \[shows.id\],  
  }),  
  artist: one(artists, {  
    fields: \[setlists.artistId\],  
    references: \[artists.id\],  
  }),  
  creator: one(users, {  
    fields: \[setlists.createdBy\],  
    references: \[users.id\],  
  }),  
  songs: many(setlistSongs),  
}));  
\`\`\`

\#\# Migration Strategy

\#\#\# Initial Migration Setup  
\`\`\`sql  
\-- migrations/0001\_initial\_schema.sql  
\-- Enable required extensions  
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";  
CREATE EXTENSION IF NOT EXISTS "postgis";  
CREATE EXTENSION IF NOT EXISTS "pg\_trgm";

\-- Create enums  
CREATE TYPE "user\_role" AS ENUM('user', 'moderator', 'admin');  
CREATE TYPE "show\_status" AS ENUM('upcoming', 'ongoing', 'completed', 'cancelled');  
CREATE TYPE "setlist\_type" AS ENUM('predicted', 'actual');  
CREATE TYPE "vote\_type" AS ENUM('up', 'down');

\-- Create tables (generated by Drizzle)  
\-- ... table creation statements ...

\-- Create indexes for performance  
CREATE INDEX idx\_artists\_spotify\_id ON artists(spotify\_id);  
CREATE INDEX idx\_shows\_date ON shows(date);  
CREATE INDEX idx\_shows\_status ON shows(status);  
CREATE INDEX idx\_venues\_location ON venues USING GIST(ST\_Point(longitude, latitude));  
CREATE INDEX idx\_setlist\_songs\_position ON setlist\_songs(setlist\_id, position);

\-- Enable Row Level Security  
ALTER TABLE users ENABLE ROW LEVEL SECURITY;  
ALTER TABLE votes ENABLE ROW LEVEL SECURITY;  
ALTER TABLE setlists ENABLE ROW LEVEL SECURITY;  
\`\`\`

\#\#\# Database Seeding  
\`\`\`typescript  
// packages/database/src/seed.ts  
import { db } from './client';  
import { artists, venues, shows } from './schema';

async function seed() {  
  console.log('ğŸŒ± Seeding database...');  
    
  // Seed sample artists  
  const sampleArtists \= await db.insert(artists).values(\[  
    {  
      name: 'The Strokes',  
      slug: 'the-strokes',  
      genres: JSON.stringify(\['indie rock', 'alternative rock'\]),  
      verified: true,  
    },  
    // ... more sample data  
  \]).returning();  
    
  console.log('âœ… Database seeded successfully');  
}

if (require.main \=== module) {  
  seed().catch(console.error);  
}  
\`\`\`

\#\# Real-time Features

\#\#\# Supabase Real-time Setup  
\`\`\`typescript  
// packages/database/src/realtime.ts  
import { supabase } from './supabase';

export function subscribeToSetlistUpdates(  
  showId: string,  
  callback: (payload: any) \=\> void  
) {  
  return supabase  
    .channel(\`setlist:${showId}\`)  
    .on(  
      'postgres\_changes',  
      {  
        event: '\*',  
        schema: 'public',  
        table: 'setlist\_songs',  
        filter: \`setlist\_id=in.(${showId})\`,  
      },  
      callback  
    )  
    .subscribe();  
}

export function subscribeToVoteUpdates(  
  setlistSongId: string,  
  callback: (payload: any) \=\> void  
) {  
  return supabase  
    .channel(\`votes:${setlistSongId}\`)  
    .on(  
      'postgres\_changes',  
      {  
        event: '\*',  
        schema: 'public',  
        table: 'votes',  
        filter: \`setlist\_song\_id=eq.${setlistSongId}\`,  
      },  
      callback  
    )  
    .subscribe();  
}  
\`\`\`

\#\# Performance Optimization

\#\#\# Query Optimization  
\`\`\`typescript  
// packages/database/src/queries/shows.ts  
import { db } from '../client';  
import { shows, artists, venues, setlists } from '../schema';  
import { eq, desc, and, sql } from 'drizzle-orm';

export async function getShowWithDetails(showId: string) {  
  return await db.query.shows.findFirst({  
    where: eq(shows.id, showId),  
    with: {  
      headlinerArtist: true,  
      venue: true,  
      setlists: {  
        with: {  
          songs: {  
            with: {  
              song: true,  
            },  
            orderBy: (setlistSongs, { asc }) \=\> \[asc(setlistSongs.position)\],  
          },  
        },  
      },  
    },  
  });  
}

export async function getTrendingShows(limit \= 20\) {  
  return await db  
    .select()  
    .from(shows)  
    .leftJoin(artists, eq(shows.headlinerArtistId, artists.id))  
    .leftJoin(venues, eq(shows.venueId, venues.id))  
    .where(eq(shows.status, 'upcoming'))  
    .orderBy(desc(shows.trendingScore))  
    .limit(limit);  
}  
\`\`\`

\#\#\# Database Triggers  
\`\`\`sql  
\-- Update vote counts trigger  
CREATE OR REPLACE FUNCTION update\_setlist\_song\_votes()  
RETURNS TRIGGER AS $$  
BEGIN  
  IF TG\_OP \= 'INSERT' THEN  
    UPDATE setlist\_songs   
    SET   
      upvotes \= upvotes \+ CASE WHEN NEW.vote\_type \= 'up' THEN 1 ELSE 0 END,  
      downvotes \= downvotes \+ CASE WHEN NEW.vote\_type \= 'down' THEN 1 ELSE 0 END,  
      net\_votes \= upvotes \- downvotes  
    WHERE id \= NEW.setlist\_song\_id;  
  END IF;  
    
  RETURN COALESCE(NEW, OLD);  
END;  
$$ LANGUAGE plpgsql;

CREATE TRIGGER setlist\_song\_vote\_count\_trigger  
  AFTER INSERT OR UPDATE OR DELETE ON votes  
  FOR EACH ROW EXECUTE FUNCTION update\_setlist\_song\_votes();  
\`\`\`

This database schema provides a solid foundation for the MySetlist application using Next-Forge's package structure with Supabase integration. The schema is designed for scalability, performance, and real-time features while maintaining type safety through Drizzle ORM.

\# MySetlist \- Authentication & User Management with Next-Forge \+ Supabase

\#\# Table of Contents  
1\. \[Authentication Overview\](\#authentication-overview)  
2\. \[Next-Forge Auth Package Modification\](\#next-forge-auth-package-modification)  
3\. \[Supabase Authentication Setup\](\#supabase-authentication-setup)  
4\. \[User Management System\](\#user-management-system)  
5\. \[Spotify Integration\](\#spotify-integration)  
6\. \[Session Management\](\#session-management)  
7\. \[Security Implementation\](\#security-implementation)  
8\. \[User Profile Features\](\#user-profile-features)

\#\# Authentication Overview

MySetlist replaces Next-Forge's default authentication with Supabase Auth while maintaining the package structure and patterns. This provides seamless integration with Spotify OAuth for music data access and traditional email/password authentication.

\#\#\# Authentication Flow  
\`\`\`  
User Login Attempt  
       â†“  
Supabase Auth Check  
       â†“  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚   First Time    â”‚   Returning     â”‚  
â”‚     User        â”‚     User        â”‚  
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  
       â†“                   â†“  
Create Profile      Update Last Login  
       â†“                   â†“  
Spotify Connect     Session Creation  
       â†“                   â†“  
    Dashboard          Dashboard  
\`\`\`

\#\#\# Authentication Methods  
\- \*\*Email/Password\*\*: Traditional authentication  
\- \*\*Spotify OAuth\*\*: Primary music platform integration  
\- \*\*Google OAuth\*\*: Alternative social login  
\- \*\*Magic Links\*\*: Passwordless email authentication

\#\# Next-Forge Auth Package Modification

\#\#\# Package Structure  
\`\`\`  
packages/auth/  
â”œâ”€â”€ src/  
â”‚   â”œâ”€â”€ config/  
â”‚   â”‚   â”œâ”€â”€ supabase.ts      \# Supabase client configuration  
â”‚   â”‚   â””â”€â”€ spotify.ts       \# Spotify OAuth settings  
â”‚   â”œâ”€â”€ providers/  
â”‚   â”‚   â”œâ”€â”€ supabase.ts      \# Supabase auth provider  
â”‚   â”‚   â”œâ”€â”€ spotify.ts       \# Spotify OAuth provider  
â”‚   â”‚   â””â”€â”€ index.ts         \# Provider exports  
â”‚   â”œâ”€â”€ hooks/  
â”‚   â”‚   â”œâ”€â”€ use-auth.ts      \# Authentication hook  
â”‚   â”‚   â”œâ”€â”€ use-user.ts      \# User data hook  
â”‚   â”‚   â””â”€â”€ use-session.ts   \# Session management hook  
â”‚   â”œâ”€â”€ components/  
â”‚   â”‚   â”œâ”€â”€ auth-forms/      \# Login/signup forms  
â”‚   â”‚   â”œâ”€â”€ auth-guard.tsx   \# Route protection  
â”‚   â”‚   â””â”€â”€ spotify-connect.tsx \# Spotify integration  
â”‚   â”œâ”€â”€ utils/  
â”‚   â”‚   â”œâ”€â”€ auth-helpers.ts  \# Authentication utilities  
â”‚   â”‚   â”œâ”€â”€ session.ts       \# Session management  
â”‚   â”‚   â””â”€â”€ validation.ts    \# Auth validation schemas  
â”‚   â”œâ”€â”€ types/  
â”‚   â”‚   â”œâ”€â”€ auth.ts          \# Authentication types  
â”‚   â”‚   â”œâ”€â”€ user.ts          \# User types  
â”‚   â”‚   â””â”€â”€ session.ts       \# Session types  
â”‚   â””â”€â”€ index.ts             \# Package exports  
â”œâ”€â”€ package.json  
â””â”€â”€ tsconfig.json  
\`\`\`

\#\#\# Core Configuration  
\`\`\`typescript  
// packages/auth/src/config/supabase.ts  
import { createClient } from '@supabase/supabase-js';

const supabaseUrl \= process.env.NEXT\_PUBLIC\_SUPABASE\_URL\!;  
const supabaseAnonKey \= process.env.NEXT\_PUBLIC\_SUPABASE\_ANON\_KEY\!;

export const supabase \= createClient(supabaseUrl, supabaseAnonKey, {  
  auth: {  
    autoRefreshToken: true,  
    persistSession: true,  
    detectSessionInUrl: true,  
  },  
});

// Server-side client for admin operations  
export const supabaseAdmin \= createClient(  
  supabaseUrl,  
  process.env.SUPABASE\_SERVICE\_ROLE\_KEY\!,  
  {  
    auth: {  
      autoRefreshToken: false,  
      persistSession: false,  
    },  
  }  
);  
\`\`\`

\#\# Supabase Authentication Setup

\#\#\# Environment Variables  
\`\`\`bash  
\# .env.local  
NEXT\_PUBLIC\_SUPABASE\_URL=your\_supabase\_url  
NEXT\_PUBLIC\_SUPABASE\_ANON\_KEY=your\_supabase\_anon\_key  
SUPABASE\_SERVICE\_ROLE\_KEY=your\_service\_role\_key

\# Spotify OAuth  
NEXT\_PUBLIC\_SPOTIFY\_CLIENT\_ID=your\_spotify\_client\_id  
SPOTIFY\_CLIENT\_SECRET=your\_spotify\_client\_secret

\# App URLs  
NEXT\_PUBLIC\_APP\_URL=http://localhost:3000  
\`\`\`

\#\#\# Supabase Auth Configuration  
\`\`\`sql  
\-- Supabase Auth settings  
UPDATE auth.config SET  
  site\_url \= 'http://localhost:3000',  
  additional\_redirect\_urls \= '\["http://localhost:3000/auth/callback"\]';

\-- Enable OAuth providers  
INSERT INTO auth.providers (name, enabled) VALUES  
  ('spotify', true),  
  ('google', true);  
\`\`\`

\#\#\# Authentication Provider Setup  
\`\`\`typescript  
// packages/auth/src/providers/supabase.ts  
import { AuthProvider, AuthUser, AuthSession } from '../types';  
import { supabase } from '../config/supabase';

export class SupabaseAuthProvider implements AuthProvider {  
  async signIn(email: string, password: string) {  
    const { data, error } \= await supabase.auth.signInWithPassword({  
      email,  
      password,  
    });

    if (error) throw new Error(error.message);  
    return this.mapUser(data.user);  
  }

  async signUp(email: string, password: string, metadata?: Record\<string, any\>) {  
    const { data, error } \= await supabase.auth.signUp({  
      email,  
      password,  
      options: {  
        data: metadata,  
      },  
    });

    if (error) throw new Error(error.message);  
    return this.mapUser(data.user);  
  }

  async signInWithOAuth(provider: 'spotify' | 'google') {  
    const { data, error } \= await supabase.auth.signInWithOAuth({  
      provider,  
      options: {  
        redirectTo: \`${process.env.NEXT\_PUBLIC\_APP\_URL}/auth/callback\`,  
        scopes: provider \=== 'spotify'   
          ? 'user-read-email user-read-private user-library-read user-top-read'  
          : undefined,  
      },  
    });

    if (error) throw new Error(error.message);  
    return data;  
  }

  async signOut() {  
    const { error } \= await supabase.auth.signOut();  
    if (error) throw new Error(error.message);  
  }

  async getSession(): Promise\<AuthSession | null\> {  
    const { data: { session }, error } \= await supabase.auth.getSession();  
    if (error) throw new Error(error.message);  
      
    return session ? this.mapSession(session) : null;  
  }

  private mapUser(user: any): AuthUser {  
    return {  
      id: user.id,  
      email: user.email,  
      emailVerified: \!\!user.email\_confirmed\_at,  
      lastSignIn: user.last\_sign\_in\_at,  
      metadata: user.user\_metadata,  
      appMetadata: user.app\_metadata,  
    };  
  }

  private mapSession(session: any): AuthSession {  
    return {  
      accessToken: session.access\_token,  
      refreshToken: session.refresh\_token,  
      expiresAt: session.expires\_at,  
      user: this.mapUser(session.user),  
    };  
  }  
}  
\`\`\`

\#\# User Management System

\#\#\# Authentication Hook  
\`\`\`typescript  
// packages/auth/src/hooks/use-auth.ts  
'use client';

import { createContext, useContext, useEffect, useState } from 'react';  
import { AuthUser, AuthSession } from '../types';  
import { SupabaseAuthProvider } from '../providers/supabase';

interface AuthContextType {  
  user: AuthUser | null;  
  session: AuthSession | null;  
  loading: boolean;  
  signIn: (email: string, password: string) \=\> Promise\<AuthUser\>;  
  signUp: (email: string, password: string, metadata?: Record\<string, any\>) \=\> Promise\<AuthUser\>;  
  signInWithSpotify: () \=\> Promise\<void\>;  
  signInWithGoogle: () \=\> Promise\<void\>;  
  signOut: () \=\> Promise\<void\>;  
  refreshSession: () \=\> Promise\<void\>;  
}

const AuthContext \= createContext\<AuthContextType | undefined\>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {  
  const \[user, setUser\] \= useState\<AuthUser | null\>(null);  
  const \[session, setSession\] \= useState\<AuthSession | null\>(null);  
  const \[loading, setLoading\] \= useState(true);  
    
  const authProvider \= new SupabaseAuthProvider();

  useEffect(() \=\> {  
    // Get initial session  
    authProvider.getSession().then((session) \=\> {  
      setSession(session);  
      setUser(session?.user || null);  
      setLoading(false);  
    });

    // Listen for auth changes  
    const { data: { subscription } } \= supabase.auth.onAuthStateChange(  
      async (event, session) \=\> {  
        if (session) {  
          const mappedSession \= authProvider.mapSession(session);  
          setSession(mappedSession);  
          setUser(mappedSession.user);  
        } else {  
          setSession(null);  
          setUser(null);  
        }  
        setLoading(false);  
      }  
    );

    return () \=\> subscription.unsubscribe();  
  }, \[\]);

  const signIn \= async (email: string, password: string) \=\> {  
    setLoading(true);  
    try {  
      return await authProvider.signIn(email, password);  
    } finally {  
      setLoading(false);  
    }  
  };

  const signUp \= async (email: string, password: string, metadata?: Record\<string, any\>) \=\> {  
    setLoading(true);  
    try {  
      return await authProvider.signUp(email, password, metadata);  
    } finally {  
      setLoading(false);  
    }  
  };

  const signInWithSpotify \= async () \=\> {  
    await authProvider.signInWithOAuth('spotify');  
  };

  const signInWithGoogle \= async () \=\> {  
    await authProvider.signInWithOAuth('google');  
  };

  const signOut \= async () \=\> {  
    setLoading(true);  
    try {  
      await authProvider.signOut();  
    } finally {  
      setLoading(false);  
    }  
  };

  const refreshSession \= async () \=\> {  
    const session \= await authProvider.getSession();  
    setSession(session);  
    setUser(session?.user || null);  
  };

  return (  
    \<AuthContext.Provider  
      value={{  
        user,  
        session,  
        loading,  
        signIn,  
        signUp,  
        signInWithSpotify,  
        signInWithGoogle,  
        signOut,  
        refreshSession,  
      }}  
    \>  
      {children}  
    \</AuthContext.Provider\>  
  );  
}

export function useAuth() {  
  const context \= useContext(AuthContext);  
  if (context \=== undefined) {  
    throw new Error('useAuth must be used within an AuthProvider');  
  }  
  return context;  
}  
\`\`\`

\#\#\# Route Protection  
\`\`\`typescript  
// packages/auth/src/components/auth-guard.tsx  
'use client';

import { useAuth } from '../hooks/use-auth';  
import { useRouter } from 'next/navigation';  
import { useEffect } from 'react';  
import { LoadingSpinner } from '@repo/ui/components/loading-spinner';

interface AuthGuardProps {  
  children: React.ReactNode;  
  fallback?: React.ReactNode;  
  redirectTo?: string;  
  requireRole?: 'user' | 'moderator' | 'admin';  
}

export function AuthGuard({   
  children,   
  fallback,   
  redirectTo \= '/auth/signin',  
  requireRole   
}: AuthGuardProps) {  
  const { user, loading } \= useAuth();  
  const router \= useRouter();

  useEffect(() \=\> {  
    if (\!loading && \!user) {  
      router.push(redirectTo);  
    }  
  }, \[user, loading, router, redirectTo\]);

  if (loading) {  
    return fallback || \<LoadingSpinner /\>;  
  }

  if (\!user) {  
    return null;  
  }

  // Role-based access control  
  if (requireRole && \!hasRole(user, requireRole)) {  
    return \<div\>Access denied. Insufficient permissions.\</div\>;  
  }

  return \<\>{children}\</\>;  
}

function hasRole(user: AuthUser, requiredRole: string): boolean {  
  const userRole \= user.appMetadata?.role || 'user';  
  const roleHierarchy \= { user: 0, moderator: 1, admin: 2 };  
    
  return roleHierarchy\[userRole\] \>= roleHierarchy\[requiredRole\];  
}  
\`\`\`

\#\# Spotify Integration

\#\#\# Spotify OAuth Configuration  
\`\`\`typescript  
// packages/auth/src/providers/spotify.ts  
import { SpotifyApi } from '@spotify/web-api-ts-sdk';

export class SpotifyAuthProvider {  
  private spotify: SpotifyApi;

  constructor(accessToken: string) {  
    this.spotify \= SpotifyApi.withAccessToken(  
      process.env.NEXT\_PUBLIC\_SPOTIFY\_CLIENT\_ID\!,  
      {  
        access\_token: accessToken,  
        token\_type: 'Bearer',  
        expires\_in: 3600,  
        refresh\_token: '',  
      }  
    );  
  }

  async getUserProfile() {  
    return await this.spotify.currentUser.profile();  
  }

  async getTopArtists(timeRange: 'short\_term' | 'medium\_term' | 'long\_term' \= 'medium\_term') {  
    return await this.spotify.currentUser.topItems('artists', timeRange, 20);  
  }

  async getTopTracks(timeRange: 'short\_term' | 'medium\_term' | 'long\_term' \= 'medium\_term') {  
    return await this.spotify.currentUser.topItems('tracks', timeRange, 20);  
  }

  async searchArtists(query: string, limit \= 20\) {  
    const results \= await this.spotify.search(query, \['artist'\], 'US', limit);  
    return results.artists;  
  }

  async getArtist(artistId: string) {  
    return await this.spotify.artists.get(artistId);  
  }

  async getArtistTopTracks(artistId: string) {  
    return await this.spotify.artists.topTracks(artistId, 'US');  
  }  
}  
\`\`\`

\#\#\# Spotify Connection Component  
\`\`\`typescript  
// packages/auth/src/components/spotify-connect.tsx  
'use client';

import { useState } from 'react';  
import { useAuth } from '../hooks/use-auth';  
import { Button } from '@repo/ui/components/button';  
import { Card } from '@repo/ui/components/card';  
import { Music } from 'lucide-react';

export function SpotifyConnect() {  
  const { user, signInWithSpotify } \= useAuth();  
  const \[isConnecting, setIsConnecting\] \= useState(false);

  const handleConnect \= async () \=\> {  
    setIsConnecting(true);  
    try {  
      await signInWithSpotify();  
    } catch (error) {  
      console.error('Spotify connection failed:', error);  
    } finally {  
      setIsConnecting(false);  
    }  
  };

  const isSpotifyConnected \= user?.appMetadata?.provider \=== 'spotify';

  if (isSpotifyConnected) {  
    return (  
      \<Card className="p-4"\>  
        \<div className="flex items-center gap-3"\>  
          \<Music className="h-5 w-5 text-green-500" /\>  
          \<div\>  
            \<p className="font-medium"\>Spotify Connected\</p\>  
            \<p className="text-sm text-muted-foreground"\>  
              Your Spotify account is linked  
            \</p\>  
          \</div\>  
        \</div\>  
      \</Card\>  
    );  
  }

  return (  
    \<Card className="p-4"\>  
      \<div className="space-y-3"\>  
        \<div className="flex items-center gap-3"\>  
          \<Music className="h-5 w-5" /\>  
          \<div\>  
            \<p className="font-medium"\>Connect Spotify\</p\>  
            \<p className="text-sm text-muted-foreground"\>  
              Get personalized artist recommendations and sync your music taste  
            \</p\>  
          \</div\>  
        \</div\>  
        \<Button  
          onClick={handleConnect}  
          disabled={isConnecting}  
          className="w-full"  
          variant="outline"  
        \>  
          {isConnecting ? 'Connecting...' : 'Connect Spotify Account'}  
        \</Button\>  
      \</div\>  
    \</Card\>  
  );  
}  
\`\`\`

\#\# Session Management

\#\#\# Server-Side Session Handling  
\`\`\`typescript  
// packages/auth/src/utils/session.ts  
import { supabaseAdmin } from '../config/supabase';  
import { cookies } from 'next/headers';

export async function getServerSession() {  
  const cookieStore \= cookies();  
  const supabaseSession \= cookieStore.get('sb-access-token');  
    
  if (\!supabaseSession?.value) {  
    return null;  
  }

  const { data: { user }, error } \= await supabaseAdmin.auth.getUser(  
    supabaseSession.value  
  );

  if (error || \!user) {  
    return null;  
  }

  return {  
    user: {  
      id: user.id,  
      email: user.email,  
      emailVerified: \!\!user.email\_confirmed\_at,  
      metadata: user.user\_metadata,  
      appMetadata: user.app\_metadata,  
    },  
  };  
}

export async function requireAuth() {  
  const session \= await getServerSession();  
  if (\!session) {  
    throw new Error('Authentication required');  
  }  
  return session;  
}

export async function requireRole(requiredRole: 'user' | 'moderator' | 'admin') {  
  const session \= await requireAuth();  
  const userRole \= session.user.appMetadata?.role || 'user';  
    
  const roleHierarchy \= { user: 0, moderator: 1, admin: 2 };  
    
  if (roleHierarchy\[userRole\] \< roleHierarchy\[requiredRole\]) {  
    throw new Error('Insufficient permissions');  
  }  
    
  return session;  
}  
\`\`\`

\#\#\# Middleware for Route Protection  
\`\`\`typescript  
// apps/web/middleware.ts  
import { createServerClient, type CookieOptions } from '@supabase/ssr';  
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {  
  let response \= NextResponse.next({  
    request: {  
      headers: request.headers,  
    },  
  });

  const supabase \= createServerClient(  
    process.env.NEXT\_PUBLIC\_SUPABASE\_URL\!,  
    process.env.NEXT\_PUBLIC\_SUPABASE\_ANON\_KEY\!,  
    {  
      cookies: {  
        get(name: string) {  
          return request.cookies.get(name)?.value;  
        },  
        set(name: string, value: string, options: CookieOptions) {  
          request.cookies.set({  
            name,  
            value,  
            ...options,  
          });  
          response \= NextResponse.next({  
            request: {  
              headers: request.headers,  
            },  
          });  
          response.cookies.set({  
            name,  
            value,  
            ...options,  
          });  
        },  
        remove(name: string, options: CookieOptions) {  
          request.cookies.set({  
            name,  
            value: '',  
            ...options,  
          });  
          response \= NextResponse.next({  
            request: {  
              headers: request.headers,  
            },  
          });  
          response.cookies.set({  
            name,  
            value: '',  
            ...options,  
          });  
        },  
      },  
    }  
  );

  await supabase.auth.getUser();

  // Protected routes  
  const protectedPaths \= \['/dashboard', '/profile', '/admin'\];  
  const authPaths \= \['/auth/signin', '/auth/signup'\];  
    
  const { pathname } \= request.nextUrl;  
  const isProtectedPath \= protectedPaths.some(path \=\> pathname.startsWith(path));  
  const isAuthPath \= authPaths.some(path \=\> pathname.startsWith(path));

  const session \= await supabase.auth.getSession();  
  const isAuthenticated \= \!\!session.data.session;

  // Redirect unauthenticated users from protected routes  
  if (isProtectedPath && \!isAuthenticated) {  
    return NextResponse.redirect(new URL('/auth/signin', request.url));  
  }

  // Redirect authenticated users from auth pages  
  if (isAuthPath && isAuthenticated) {  
    return NextResponse.redirect(new URL('/dashboard', request.url));  
  }

  return response;  
}

export const config \= {  
  matcher: \[  
    '/((?\!api|\_next/static|\_next/image|favicon.ico).\*)',  
  \],  
};  
\`\`\`

\#\# Security Implementation

\#\#\# Row Level Security Policies  
\`\`\`sql  
\-- Enable RLS on user-related tables  
ALTER TABLE users ENABLE ROW LEVEL SECURITY;  
ALTER TABLE user\_profiles ENABLE ROW LEVEL SECURITY;

\-- Users can read their own data  
CREATE POLICY "Users can view own profile" ON users  
  FOR SELECT USING (auth.uid() \= id);

CREATE POLICY "Users can update own profile" ON users  
  FOR UPDATE USING (auth.uid() \= id);

\-- Profile access policies  
CREATE POLICY "Users can view own profile details" ON user\_profiles  
  FOR SELECT USING (auth.uid() \= user\_id);

CREATE POLICY "Users can update own profile details" ON user\_profiles  
  FOR UPDATE USING (auth.uid() \= user\_id);

CREATE POLICY "Users can insert own profile" ON user\_profiles  
  FOR INSERT WITH CHECK (auth.uid() \= user\_id);

\-- Public profiles are viewable by all  
CREATE POLICY "Public profiles are viewable" ON user\_profiles  
  FOR SELECT USING (is\_public \= true);  
\`\`\`

\#\#\# Input Validation  
\`\`\`typescript  
// packages/auth/src/utils/validation.ts  
import { z } from 'zod';

export const signInSchema \= z.object({  
  email: z.string().email('Invalid email address'),  
  password: z.string().min(8, 'Password must be at least 8 characters'),  
});

export const signUpSchema \= z.object({  
  email: z.string().email('Invalid email address'),  
  password: z  
    .string()  
    .min(8, 'Password must be at least 8 characters')  
    .regex(  
      /^(?=.\*\[a-z\])(?=.\*\[A-Z\])(?=.\*\\d)/,  
      'Password must contain at least one uppercase letter, one lowercase letter, and one number'  
    ),  
  displayName: z.string().min(2, 'Display name must be at least 2 characters'),  
});

export const profileUpdateSchema \= z.object({  
  displayName: z.string().min(2).max(50).optional(),  
  bio: z.string().max(500).optional(),  
  location: z.string().max(100).optional(),  
  website: z.string().url().optional(),  
  favoriteGenres: z.array(z.string()).max(10).optional(),  
});  
\`\`\`

\#\# User Profile Features

\#\#\# Profile Management Hook  
\`\`\`typescript  
// packages/auth/src/hooks/use-user-profile.ts  
'use client';

import { useState, useEffect } from 'react';  
import { useAuth } from './use-auth';  
import { db } from '@repo/database';  
import { userProfiles } from '@repo/database/schema';  
import { eq } from 'drizzle-orm';

export function useUserProfile() {  
  const { user } \= useAuth();  
  const \[profile, setProfile\] \= useState(null);  
  const \[loading, setLoading\] \= useState(true);

  useEffect(() \=\> {  
    if (user) {  
      fetchProfile();  
    } else {  
      setProfile(null);  
      setLoading(false);  
    }  
  }, \[user\]);

  const fetchProfile \= async () \=\> {  
    if (\!user) return;  
      
    try {  
      const result \= await db.query.userProfiles.findFirst({  
        where: eq(userProfiles.userId, user.id),  
      });  
      setProfile(result);  
    } catch (error) {  
      console.error('Failed to fetch profile:', error);  
    } finally {  
      setLoading(false);  
    }  
  };

  const updateProfile \= async (updates: Partial\<UserProfile\>) \=\> {  
    if (\!user) return;

    try {  
      await db  
        .update(userProfiles)  
        .set({ ...updates, updatedAt: new Date() })  
        .where(eq(userProfiles.userId, user.id));  
        
      await fetchProfile();  
    } catch (error) {  
      console.error('Failed to update profile:', error);  
      throw error;  
    }  
  };

  return {  
    profile,  
    loading,  
    updateProfile,  
    refetch: fetchProfile,  
  };  
}  
\`\`\`

This authentication system provides a robust foundation for MySetlist using Next-Forge's package structure with Supabase integration. It supports multiple authentication methods, secure session management, and integrates seamlessly with Spotify for music-related features.

\# MySetlist \- Core Features & Components Architecture

\#\# Table of Contents  
1\. \[Component Architecture Overview\](\#component-architecture-overview)  
2\. \[Next-Forge UI Package Extensions\](\#next-forge-ui-package-extensions)  
3\. \[Artist Discovery System\](\#artist-discovery-system)  
4\. \[Show & Venue Management\](\#show--venue-management)  
5\. \[Setlist Voting System\](\#setlist-voting-system)  
6\. \[Search & Discovery Features\](\#search--discovery-features)  
7\. \[Real-time Updates\](\#real-time-updates)  
8. [Responsive Web Features](#responsive-web-features)

\#\# Component Architecture Overview

MySetlist builds upon Next-Forge's UI package structure, extending it with music-specific components while maintaining consistency with the design system. The architecture follows atomic design principles with shared components in the UI package and feature-specific components in the web app.

\#\#\# Component Hierarchy  
\`\`\`  
@repo/ui (Shared Components)  
â”œâ”€â”€ Atoms  
â”‚   â”œâ”€â”€ Button, Input, Badge, Avatar  
â”‚   â”œâ”€â”€ LoadingSpinner, ProgressBar  
â”‚   â””â”€â”€ VoteButton, PlayButton  
â”œâ”€â”€ Molecules    
â”‚   â”œâ”€â”€ SearchBox, FilterTabs  
â”‚   â”œâ”€â”€ ArtistCard, VenueCard  
â”‚   â””â”€â”€ SetlistSong, VoteCounter  
â”œâ”€â”€ Organisms  
â”‚   â”œâ”€â”€ ArtistGrid, ShowList  
â”‚   â”œâ”€â”€ SetlistViewer, SearchResults  
â”‚   â””â”€â”€ Navigation, Header  
â””â”€â”€ Templates  
    â”œâ”€â”€ PageLayout, DashboardLayout  
    â””â”€â”€ AuthLayout, ModalLayout

apps/web/components (Feature Components)  
â”œâ”€â”€ artist/  
â”œâ”€â”€ show/  
â”œâ”€â”€ setlist/  
â”œâ”€â”€ venue/  
â””â”€â”€ search/  
\`\`\`

\#\#\# Design System Extension  
\`\`\`typescript  
// packages/ui/src/lib/design-tokens.ts  
export const musicTokens \= {  
  colors: {  
    spotify: '\#1DB954',  
    spotifyDark: '\#1ed760',  
    vinyl: '\#2a2a2a',  
    stage: '\#ff6b35',  
    audience: '\#4a90e2',  
    vote: {  
      up: '\#22c55e',  
      down: '\#ef4444',  
      neutral: '\#64748b',  
    },  
  },  
  spacing: {  
    setlistGap: '0.75rem',  
    cardPadding: '1.5rem',  
    searchRadius: '0.75rem',  
  },  
  typography: {  
    artistName: 'font-bold text-2xl tracking-tight',  
    showTitle: 'font-semibold text-lg',  
    songTitle: 'font-medium text-base',  
    venueName: 'font-medium text-sm text-muted-foreground',  
  },  
} as const;  
\`\`\`

\#\# Next-Forge UI Package Extensions

\#\#\# Music-Specific Components  
\`\`\`typescript  
// packages/ui/src/components/music/artist-card.tsx  
import { Card, CardContent, CardHeader } from '../card';  
import { Avatar, AvatarFallback, AvatarImage } from '../avatar';  
import { Badge } from '../badge';  
import { Button } from '../button';  
import { Heart, Music, Users } from 'lucide-react';

interface ArtistCardProps {  
  artist: {  
    id: string;  
    name: string;  
    imageUrl?: string;  
    genres: string\[\];  
    followers: number;  
    isFollowing?: boolean;  
  };  
  onFollow?: (artistId: string) \=\> void;  
  variant?: 'default' | 'compact' | 'detailed';  
}

export function ArtistCard({ artist, onFollow, variant \= 'default' }: ArtistCardProps) {  
  const formatFollowers \= (count: number) \=\> {  
    if (count \>= 1000000\) return \`${(count / 1000000).toFixed(1)}M\`;  
    if (count \>= 1000\) return \`${(count / 1000).toFixed(1)}K\`;  
    return count.toString();  
  };

  return (  
    \<Card className="group hover:shadow-lg transition-all duration-200"\>  
      \<CardHeader className="pb-3"\>  
        \<div className="flex items-start justify-between"\>  
          \<div className="flex items-center gap-3"\>  
            \<Avatar className="h-12 w-12"\>  
              \<AvatarImage src={artist.imageUrl} alt={artist.name} /\>  
              \<AvatarFallback\>  
                \<Music className="h-6 w-6" /\>  
              \</AvatarFallback\>  
            \</Avatar\>  
            \<div\>  
              \<h3 className="font-semibold text-lg leading-none"\>  
                {artist.name}  
              \</h3\>  
              \<div className="flex items-center gap-1 mt-1 text-sm text-muted-foreground"\>  
                \<Users className="h-3 w-3" /\>  
                {formatFollowers(artist.followers)} followers  
              \</div\>  
            \</div\>  
          \</div\>  
          {onFollow && (  
            \<Button  
              variant={artist.isFollowing ? 'default' : 'outline'}  
              size="sm"  
              onClick={() \=\> onFollow(artist.id)}  
            \>  
              \<Heart className={\`h-4 w-4 mr-1 ${artist.isFollowing ? 'fill-current' : ''}\`} /\>  
              {artist.isFollowing ? 'Following' : 'Follow'}  
            \</Button\>  
          )}  
        \</div\>  
      \</CardHeader\>  
      \<CardContent\>  
        \<div className="flex flex-wrap gap-1"\>  
          {artist.genres.slice(0, 3).map((genre) \=\> (  
            \<Badge key={genre} variant="secondary" className="text-xs"\>  
              {genre}  
            \</Badge\>  
          ))}  
        \</div\>  
      \</CardContent\>  
    \</Card\>  
  );  
}  
\`\`\`

\#\#\# Voting System Components  
\`\`\`typescript  
// packages/ui/src/components/music/vote-button.tsx  
'use client';

import { useState } from 'react';  
import { Button } from '../button';  
import { ChevronUp, ChevronDown } from 'lucide-react';  
import { cn } from '../../lib/utils';

interface VoteButtonProps {  
  songId: string;  
  currentVote?: 'up' | 'down' | null;  
  upvotes: number;  
  downvotes: number;  
  onVote: (songId: string, voteType: 'up' | 'down' | null) \=\> Promise\<void\>;  
  disabled?: boolean;  
}

export function VoteButton({  
  songId,  
  currentVote,  
  upvotes,  
  downvotes,  
  onVote,  
  disabled \= false,  
}: VoteButtonProps) {  
  const \[isVoting, setIsVoting\] \= useState(false);  
  const netVotes \= upvotes \- downvotes;

  const handleVote \= async (voteType: 'up' | 'down') \=\> {  
    if (isVoting || disabled) return;  
      
    setIsVoting(true);  
    try {  
      // Toggle vote if same type, otherwise switch  
      const newVote \= currentVote \=== voteType ? null : voteType;  
      await onVote(songId, newVote);  
    } catch (error) {  
      console.error('Vote failed:', error);  
    } finally {  
      setIsVoting(false);  
    }  
  };

  return (  
    \<div className="flex items-center gap-1"\>  
      \<Button  
        variant="ghost"  
        size="sm"  
        onClick={() \=\> handleVote('up')}  
        disabled={isVoting || disabled}  
        className={cn(  
          'h-8 w-8 p-0',  
          currentVote \=== 'up' && 'bg-green-100 text-green-700 hover:bg-green-200'  
        )}  
      \>  
        \<ChevronUp className="h-4 w-4" /\>  
      \</Button\>  
        
      \<span className={cn(  
        'text-sm font-medium min-w-\[2rem\] text-center',  
        netVotes \> 0 && 'text-green-600',  
        netVotes \< 0 && 'text-red-600',  
        netVotes \=== 0 && 'text-muted-foreground'  
      )}\>  
        {netVotes \> 0 ? \`+${netVotes}\` : netVotes}  
      \</span\>  
        
      \<Button  
        variant="ghost"  
        size="sm"  
        onClick={() \=\> handleVote('down')}  
        disabled={isVoting || disabled}  
        className={cn(  
          'h-8 w-8 p-0',  
          currentVote \=== 'down' && 'bg-red-100 text-red-700 hover:bg-red-200'  
        )}  
      \>  
        \<ChevronDown className="h-4 w-4" /\>  
      \</Button\>  
    \</div\>  
  );  
}  
\`\`\`

\#\#\# Search Components  
\`\`\`typescript  
// packages/ui/src/components/search/search-box.tsx  
'use client';

import { useState, useCallback, useRef, useEffect } from 'react';  
import { Search, X } from 'lucide-react';  
import { Input } from '../input';  
import { Button } from '../button';  
import { Command, CommandInput, CommandList, CommandEmpty, CommandGroup, CommandItem } from '../command';  
import { Popover, PopoverContent, PopoverTrigger } from '../popover';  
import { useDebounce } from '../../hooks/use-debounce';

interface SearchResult {  
  id: string;  
  type: 'artist' | 'show' | 'venue' | 'song';  
  title: string;  
  subtitle?: string;  
  imageUrl?: string;  
}

interface SearchBoxProps {  
  placeholder?: string;  
  onSearch: (query: string) \=\> Promise\<SearchResult\[\]\>;  
  onSelect: (result: SearchResult) \=\> void;  
  className?: string;  
}

export function SearchBox({   
  placeholder \= 'Search artists, shows, venues...',   
  onSearch,   
  onSelect,  
  className   
}: SearchBoxProps) {  
  const \[query, setQuery\] \= useState('');  
  const \[results, setResults\] \= useState\<SearchResult\[\]\>(\[\]);  
  const \[isLoading, setIsLoading\] \= useState(false);  
  const \[isOpen, setIsOpen\] \= useState(false);  
    
  const debouncedQuery \= useDebounce(query, 300);

  useEffect(() \=\> {  
    if (debouncedQuery.length \>= 2\) {  
      performSearch(debouncedQuery);  
    } else {  
      setResults(\[\]);  
    }  
  }, \[debouncedQuery\]);

  const performSearch \= async (searchQuery: string) \=\> {  
    setIsLoading(true);  
    try {  
      const searchResults \= await onSearch(searchQuery);  
      setResults(searchResults);  
      setIsOpen(true);  
    } catch (error) {  
      console.error('Search failed:', error);  
      setResults(\[\]);  
    } finally {  
      setIsLoading(false);  
    }  
  };

  const handleSelect \= (result: SearchResult) \=\> {  
    onSelect(result);  
    setQuery('');  
    setResults(\[\]);  
    setIsOpen(false);  
  };

  const clearSearch \= () \=\> {  
    setQuery('');  
    setResults(\[\]);  
    setIsOpen(false);  
  };

  return (  
    \<Popover open={isOpen} onOpenChange={setIsOpen}\>  
      \<PopoverTrigger asChild\>  
        \<div className={cn('relative', className)}\>  
          \<Search className="absolute left-3 top-1/2 h-4 w-4 \-translate-y-1/2 text-muted-foreground" /\>  
          \<Input  
            value={query}  
            onChange={(e) \=\> setQuery(e.target.value)}  
            placeholder={placeholder}  
            className="pl-10 pr-10"  
            onFocus={() \=\> setIsOpen(query.length \>= 2 && results.length \> 0)}  
          /\>  
          {query && (  
            \<Button  
              variant="ghost"  
              size="sm"  
              onClick={clearSearch}  
              className="absolute right-2 top-1/2 h-6 w-6 \-translate-y-1/2 p-0"  
            \>  
              \<X className="h-4 w-4" /\>  
            \</Button\>  
          )}  
        \</div\>  
      \</PopoverTrigger\>  
      \<PopoverContent className="w-\[400px\] p-0" align="start"\>  
        \<Command shouldFilter={false}\>  
          \<CommandList\>  
            {isLoading && (  
              \<CommandEmpty\>Searching...\</CommandEmpty\>  
            )}  
            {\!isLoading && results.length \=== 0 && query.length \>= 2 && (  
              \<CommandEmpty\>No results found.\</CommandEmpty\>  
            )}  
            {results.length \> 0 && (  
              \<CommandGroup\>  
                {results.map((result) \=\> (  
                  \<CommandItem  
                    key={result.id}  
                    onSelect={() \=\> handleSelect(result)}  
                    className="flex items-center gap-3 p-3"  
                  \>  
                    {result.imageUrl && (  
                      \<img  
                        src={result.imageUrl}  
                        alt={result.title}  
                        className="h-10 w-10 rounded object-cover"  
                      /\>  
                    )}  
                    \<div\>  
                      \<div className="font-medium"\>{result.title}\</div\>  
                      {result.subtitle && (  
                        \<div className="text-sm text-muted-foreground"\>  
                          {result.subtitle}  
                        \</div\>  
                      )}  
                    \</div\>  
                    \<Badge variant="outline" className="ml-auto"\>  
                      {result.type}  
                    \</Badge\>  
                  \</CommandItem\>  
                ))}  
              \</CommandGroup\>  
            )}  
          \</CommandList\>  
        \</Command\>  
      \</PopoverContent\>  
    \</Popover\>  
  );  
}  
\`\`\`

\#\# Artist Discovery System

\#\#\# Artist Profile Page  
\`\`\`typescript  
// apps/web/app/artists/\[slug\]/page.tsx  
import { Metadata } from 'next';  
import { notFound } from 'next/navigation';  
import { ArtistHeader } from './components/artist-header';  
import { ArtistStats } from './components/artist-stats';  
import { RecentShows } from './components/recent-shows';  
import { UpcomingShows } from './components/upcoming-shows';  
import { TopTracks } from './components/top-tracks';  
import { getArtistBySlug } from '@repo/database/queries/artists';

interface ArtistPageProps {  
  params: { slug: string };  
}

export async function generateMetadata({ params }: ArtistPageProps): Promise\<Metadata\> {  
  const artist \= await getArtistBySlug(params.slug);  
    
  if (\!artist) {  
    return { title: 'Artist Not Found' };  
  }

  return {  
    title: \`${artist.name} \- Concert Setlists | MySetlist\`,  
    description: \`View ${artist.name}'s concert setlists, show history, and upcoming tour dates. Follow to get notified of new shows.\`,  
    openGraph: {  
      title: artist.name,  
      description: \`Concert setlists and show history for ${artist.name}\`,  
      images: artist.imageUrl ? \[{ url: artist.imageUrl }\] : \[\],  
    },  
  };  
}

export default async function ArtistPage({ params }: ArtistPageProps) {  
  const artist \= await getArtistBySlug(params.slug);  
    
  if (\!artist) {  
    notFound();  
  }

  return (  
    \<div className="container mx-auto px-4 py-8"\>  
      \<ArtistHeader artist={artist} /\>  
        
      \<div className="mt-8 grid grid-cols-1 lg:grid-cols-3 gap-8"\>  
        \<div className="lg:col-span-2 space-y-8"\>  
          \<UpcomingShows artistId={artist.id} /\>  
          \<RecentShows artistId={artist.id} /\>  
        \</div\>  
          
        \<div className="space-y-8"\>  
          \<ArtistStats artist={artist} /\>  
          \<TopTracks artistId={artist.id} /\>  
        \</div\>  
      \</div\>  
    \</div\>  
  );  
}  
\`\`\`

\#\#\# Artist Discovery Hook  
\`\`\`typescript  
// apps/web/hooks/use-artist-discovery.ts  
'use client';

import { useState, useEffect } from 'react';  
import { useAuth } from '@repo/auth';  
import { SpotifyAuthProvider } from '@repo/auth/providers/spotify';

interface DiscoveryOptions {  
  genres?: string\[\];  
  popularity?: 'high' | 'medium' | 'low';  
  location?: { lat: number; lng: number; radius: number };  
  includeSpotifyRecommendations?: boolean;  
}

export function useArtistDiscovery(options: DiscoveryOptions \= {}) {  
  const { session } \= useAuth();  
  const \[recommendations, setRecommendations\] \= useState(\[\]);  
  const \[loading, setLoading\] \= useState(false);

  const getRecommendations \= async () \=\> {  
    setLoading(true);  
    try {  
      // Fetch from our API which combines multiple sources  
      const response \= await fetch('/api/artists/discover', {  
        method: 'POST',  
        headers: { 'Content-Type': 'application/json' },  
        body: JSON.stringify(options),  
      });  
        
      const data \= await response.json();  
      setRecommendations(data.artists);  
        
      // If user has Spotify connected, enhance with Spotify recommendations  
      if (session?.provider \=== 'spotify' && options.includeSpotifyRecommendations) {  
        const spotifyRecommendations \= await getSpotifyRecommendations();  
        setRecommendations(prev \=\> \[...prev, ...spotifyRecommendations\]);  
      }  
    } catch (error) {  
      console.error('Failed to get recommendations:', error);  
    } finally {  
      setLoading(false);  
    }  
  };

  const getSpotifyRecommendations \= async () \=\> {  
    if (\!session?.access\_token) return \[\];  
      
    const spotify \= new SpotifyAuthProvider(session.access\_token);  
    const topArtists \= await spotify.getTopArtists();  
      
    // Use top artists as seeds for recommendations  
    const seedArtists \= topArtists.items.slice(0, 5).map(artist \=\> artist.id);  
      
    return fetch('/api/spotify/recommendations', {  
      method: 'POST',  
      headers: { 'Content-Type': 'application/json' },  
      body: JSON.stringify({ seedArtists }),  
    }).then(res \=\> res.json());  
  };

  useEffect(() \=\> {  
    getRecommendations();  
  }, \[JSON.stringify(options)\]);

  return {  
    recommendations,  
    loading,  
    refresh: getRecommendations,  
  };  
}  
\`\`\`

\#\# Show & Venue Management

\#\#\# Show Detail Page  
\`\`\`typescript  
// apps/web/app/shows/\[id\]/page.tsx  
import { Metadata } from 'next';  
import { notFound } from 'next/navigation';  
import { ShowHeader } from './components/show-header';  
import { SetlistContainer } from './components/setlist-container';  
import { ShowInfo } from './components/show-info';  
import { AttendeeList } from './components/attendee-list';  
import { getShowById } from '@repo/database/queries/shows';

interface ShowPageProps {  
  params: { id: string };  
}

export default async function ShowPage({ params }: ShowPageProps) {  
  const show \= await getShowById(params.id);  
    
  if (\!show) {  
    notFound();  
  }

  return (  
    \<div className="container mx-auto px-4 py-8"\>  
      \<ShowHeader show={show} /\>  
        
      \<div className="mt-8 grid grid-cols-1 lg:grid-cols-4 gap-8"\>  
        \<div className="lg:col-span-3"\>  
          \<SetlistContainer showId={show.id} /\>  
        \</div\>  
          
        \<div className="space-y-6"\>  
          \<ShowInfo show={show} /\>  
          \<AttendeeList showId={show.id} /\>  
        \</div\>  
      \</div\>  
    \</div\>  
  );  
}  
\`\`\`

\#\#\# Venue Search with Location  
\`\`\`typescript  
// apps/web/components/venue/venue-search.tsx  
'use client';

import { useState, useEffect } from 'react';  
import { MapPin } from 'lucide-react';  
import { SearchBox } from '@repo/ui/components/search/search-box';  
import { VenueCard } from '@repo/ui/components/music/venue-card';  
import { Button } from '@repo/ui/components/button';  
import { useGeolocation } from '../../hooks/use-geolocation';

export function VenueSearch() {  
  const \[venues, setVenues\] \= useState(\[\]);  
  const \[location, setLocation\] \= useState(null);  
  const { coordinates, loading: locationLoading, requestLocation } \= useGeolocation();

  const searchVenues \= async (query: string) \=\> {  
    const searchParams \= new URLSearchParams({  
      q: query,  
      ...(location && {  
        lat: location.lat.toString(),  
        lng: location.lng.toString(),  
        radius: '50', // 50km radius  
      }),  
    });

    const response \= await fetch(\`/api/venues/search?${searchParams}\`);  
    return response.json();  
  };

  const handleVenueSelect \= (venue) \=\> {  
    // Navigate to venue page  
    window.location.href \= \`/venues/${venue.slug}\`;  
  };

  const handleLocationRequest \= async () \=\> {  
    const coords \= await requestLocation();  
    if (coords) {  
      setLocation(coords);  
    }  
  };

  useEffect(() \=\> {  
    if (coordinates) {  
      setLocation(coordinates);  
    }  
  }, \[coordinates\]);

  return (  
    \<div className="space-y-6"\>  
      \<div className="flex gap-4"\>  
        \<div className="flex-1"\>  
          \<SearchBox  
            placeholder="Search venues by name or location..."  
            onSearch={searchVenues}  
            onSelect={handleVenueSelect}  
          /\>  
        \</div\>  
        \<Button  
          variant="outline"  
          onClick={handleLocationRequest}  
          disabled={locationLoading}  
        \>  
          \<MapPin className="h-4 w-4 mr-2" /\>  
          {locationLoading ? 'Getting location...' : 'Near me'}  
        \</Button\>  
      \</div\>

      {location && (  
        \<p className="text-sm text-muted-foreground"\>  
          Showing venues within 50km of your location  
        \</p\>  
      )}

      \<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"\>  
        {venues.map((venue) \=\> (  
          \<VenueCard key={venue.id} venue={venue} /\>  
        ))}  
      \</div\>  
    \</div\>  
  );  
}  
\`\`\`

\#\# Setlist Voting System

\#\#\# Real-time Setlist Component  
\`\`\`typescript  
// apps/web/components/setlist/setlist-viewer.tsx  
'use client';

import { useState, useEffect } from 'react';  
import { useAuth } from '@repo/auth';  
import { VoteButton } from '@repo/ui/components/music/vote-button';  
import { Card, CardContent, CardHeader, CardTitle } from '@repo/ui/components/card';  
import { Badge } from '@repo/ui/components/badge';  
import { Music, Clock, Users } from 'lucide-react';  
import { subscribeToSetlistUpdates, subscribeToVoteUpdates } from '@repo/database/realtime';

interface SetlistViewerProps {  
  showId: string;  
  initialSetlist: any;  
}

export function SetlistViewer({ showId, initialSetlist }: SetlistViewerProps) {  
  const { user } \= useAuth();  
  const \[setlist, setSetlist\] \= useState(initialSetlist);  
  const \[userVotes, setUserVotes\] \= useState({});

  useEffect(() \=\> {  
    // Subscribe to real-time updates  
    const subscription \= subscribeToSetlistUpdates(showId, (payload) \=\> {  
      if (payload.eventType \=== 'UPDATE') {  
        setSetlist(prev \=\> ({  
          ...prev,  
          songs: prev.songs.map(song \=\>   
            song.id \=== payload.new.id ? { ...song, ...payload.new } : song  
          ),  
        }));  
      }  
    });

    return () \=\> subscription?.unsubscribe();  
  }, \[showId\]);

  const handleVote \= async (songId: string, voteType: 'up' | 'down' | null) \=\> {  
    if (\!user) return;

    try {  
      const response \= await fetch('/api/votes', {  
        method: 'POST',  
        headers: { 'Content-Type': 'application/json' },  
        body: JSON.stringify({  
          setlistSongId: songId,  
          voteType,  
        }),  
      });

      if (\!response.ok) throw new Error('Vote failed');

      // Update local state optimistically  
      setUserVotes(prev \=\> ({  
        ...prev,  
        \[songId\]: voteType,  
      }));  
    } catch (error) {  
      console.error('Vote failed:', error);  
    }  
  };

  const formatDuration \= (ms: number) \=\> {  
    const minutes \= Math.floor(ms / 60000);  
    const seconds \= Math.floor((ms % 60000\) / 1000);  
    return \`${minutes}:${seconds.toString().padStart(2, '0')}\`;  
  };

  return (  
    \<div className="space-y-4"\>  
      \<Card\>  
        \<CardHeader\>  
          \<CardTitle className="flex items-center gap-2"\>  
            \<Music className="h-5 w-5" /\>  
            {setlist.name}  
            \<Badge variant={setlist.type \=== 'actual' ? 'default' : 'secondary'}\>  
              {setlist.type}  
            \</Badge\>  
          \</CardTitle\>  
        \</CardHeader\>  
        \<CardContent\>  
          \<div className="space-y-3"\>  
            {setlist.songs.map((song, index) \=\> (  
              \<div  
                key={song.id}  
                className="flex items-center gap-4 p-3 rounded-lg border bg-card"  
              \>  
                \<div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center text-sm font-medium"\>  
                  {index \+ 1}  
                \</div\>  
                  
                \<div className="flex-1"\>  
                  \<div className="font-medium"\>{song.song.title}\</div\>  
                  \<div className="flex items-center gap-4 text-sm text-muted-foreground"\>  
                    \<span\>{song.song.artist}\</span\>  
                    {song.song.durationMs && (  
                      \<\>  
                        \<Clock className="h-3 w-3" /\>  
                        {formatDuration(song.song.durationMs)}  
                      \</\>  
                    )}  
                    {song.notes && (  
                      \<Badge variant="outline" className="text-xs"\>  
                        {song.notes}  
                      \</Badge\>  
                    )}  
                  \</div\>  
                \</div\>

                {user && setlist.type \=== 'predicted' && (  
                  \<VoteButton  
                    songId={song.id}  
                    currentVote={userVotes\[song.id\]}  
                    upvotes={song.upvotes}  
                    downvotes={song.downvotes}  
                    onVote={handleVote}  
                    disabled={setlist.isLocked}  
                  /\>  
                )}

                \<div className="flex items-center gap-1 text-sm text-muted-foreground"\>  
                  \<Users className="h-3 w-3" /\>  
                  {song.upvotes \+ song.downvotes}  
                \</div\>  
              \</div\>  
            ))}  
          \</div\>  
        \</CardContent\>  
      \</Card\>  
    \</div\>  
  );  
}  
\`\`\`

\#\# Search & Discovery Features

\#\#\# Global Search API  
\`\`\`typescript  
// apps/web/app/api/search/route.ts  
import { NextRequest } from 'next/server';  
import { db } from '@repo/database';  
import { artists, shows, venues, songs } from '@repo/database/schema';  
import { ilike, or, sql } from 'drizzle-orm';

export async function GET(request: NextRequest) {  
  const { searchParams } \= new URL(request.url);  
  const query \= searchParams.get('q');  
  const type \= searchParams.get('type'); // 'artist', 'show', 'venue', 'all'  
  const limit \= parseInt(searchParams.get('limit') || '20');

  if (\!query || query.length \< 2\) {  
    return Response.json({ results: \[\] });  
  }

  try {  
    const results \= \[\];

    // Search artists  
    if (\!type || type \=== 'artist' || type \=== 'all') {  
      const artistResults \= await db  
        .select({  
          id: artists.id,  
          type: sql\<string\>\`'artist'\`,  
          title: artists.name,  
          subtitle: sql\<string\>\`COALESCE(${artists.bio}, '')\`,  
          imageUrl: artists.imageUrl,  
          slug: artists.slug,  
        })  
        .from(artists)  
        .where(  
          or(  
            ilike(artists.name, \`%${query}%\`),  
            sql\`${artists.genres}::text ILIKE ${'%' \+ query \+ '%'}\`  
          )  
        )  
        .limit(type \=== 'artist' ? limit : Math.floor(limit / 3));

      results.push(...artistResults);  
    }

    // Search shows  
    if (\!type || type \=== 'show' || type \=== 'all') {  
      const showResults \= await db  
        .select({  
          id: shows.id,  
          type: sql\<string\>\`'show'\`,  
          title: shows.name,  
          subtitle: sql\<string\>\`${artists.name} || ' â€¢ ' || ${venues.name}\`,  
          imageUrl: artists.imageUrl,  
          slug: shows.slug,  
        })  
        .from(shows)  
        .leftJoin(artists, eq(shows.headlinerArtistId, artists.id))  
        .leftJoin(venues, eq(shows.venueId, venues.id))  
        .where(ilike(shows.name, \`%${query}%\`))  
        .limit(type \=== 'show' ? limit : Math.floor(limit / 3));

      results.push(...showResults);  
    }

    // Search venues  
    if (\!type || type \=== 'venue' || type \=== 'all') {  
      const venueResults \= await db  
        .select({  
          id: venues.id,  
          type: sql\<string\>\`'venue'\`,  
          title: venues.name,  
          subtitle: sql\<string\>\`${venues.city} || ', ' || ${venues.country}\`,  
          imageUrl: venues.imageUrl,  
          slug: venues.slug,  
        })  
        .from(venues)  
        .where(  
          or(  
            ilike(venues.name, \`%${query}%\`),  
            ilike(venues.city, \`%${query}%\`)  
          )  
        )  
        .limit(type \=== 'venue' ? limit : Math.floor(limit / 3));

      results.push(...venueResults);  
    }

    return Response.json({ results });  
  } catch (error) {  
    console.error('Search failed:', error);  
    return Response.json({ error: 'Search failed' }, { status: 500 });  
  }  
}  
\`\`\`

\#\# Real-time Updates

\#\#\# WebSocket Integration  
\`\`\`typescript  
// apps/web/lib/websocket.ts  
'use client';

import { useEffect, useRef } from 'react';  
import { supabase } from '@repo/database/supabase';

export function useRealtimeSubscription(  
  table: string,  
  filter?: string,  
  callback?: (payload: any) \=\> void  
) {  
  const subscriptionRef \= useRef(null);

  useEffect(() \=\> {  
    const channel \= supabase  
      .channel(\`realtime:${table}\`)  
      .on(  
        'postgres\_changes',  
        {  
          event: '\*',  
          schema: 'public',  
          table,  
          ...(filter && { filter }),  
        },  
        (payload) \=\> {  
          callback?.(payload);  
        }  
      )  
      .subscribe();

    subscriptionRef.current \= channel;

    return () \=\> {  
      if (subscriptionRef.current) {  
        supabase.removeChannel(subscriptionRef.current);  
      }  
    };  
  }, \[table, filter, callback\]);

  return subscriptionRef.current;  
}  
\`\`\`

## Responsive Web Features

### Mobile-First Design
The application follows a mobile-first responsive design approach, ensuring optimal user experience across all device sizes:

```typescript
// Responsive design patterns
const responsiveClasses = {
  container: 'container mx-auto px-4 md:px-6 lg:px-8',
  grid: 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3',
  navigation: 'hidden md:flex', // Desktop navigation
  mobileMenu: 'flex md:hidden', // Mobile menu
  searchBar: 'w-full md:max-w-md lg:max-w-lg',
};
```

### Touch-Optimized Interface
Components are designed with touch interactions in mind:

```typescript
// Touch-friendly sizing and interactions
const touchOptimized = {
  buttons: 'min-h-[44px] min-w-[44px] touch-manipulation',
  links: 'block py-3 px-4 touch-manipulation',
  cards: 'rounded-lg shadow-sm hover:shadow-md transition-shadow',
  votingButtons: 'p-3 rounded-full active:scale-95 transition-transform',
};
```

### Internet Connection Required
MySetlist is designed as an online-first web application that requires an internet connection for all functionality. Real-time features enhance the experience when connected.
This architecture provides a solid foundation for MySetlist's core features while maintaining the Next-Forge structure and patterns. The components are designed to be reusable, performant, and provide excellent user experience across desktop and mobile devices.

\# MySetlist \- API Integrations & External Services

\#\# Table of Contents  
1\. \[External APIs Overview\](\#external-apis-overview)  
2\. \[Next-Forge External APIs Package\](\#next-forge-external-apis-package)  
3\. \[Spotify API Integration\](\#spotify-api-integration)  
4\. \[Ticketmaster API Integration\](\#ticketmaster-api-integration)  
5\. \[Setlist.fm API Integration\](\#setlistfm-api-integration)  
6\. \[Data Synchronization Strategy\](\#data-synchronization-strategy)  
7\. \[Rate Limiting & Caching\](\#rate-limiting--caching)  
8\. \[Error Handling & Resilience\](\#error-handling--resilience)

\#\# External APIs Overview

MySetlist integrates with multiple external APIs to provide comprehensive music data. The integration follows Next-Forge's package structure with a dedicated external-apis package that handles all third-party service interactions.

\#\#\# API Service Architecture  
\`\`\`  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚                MySetlist Application                        â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  @repo/external-apis Package                            â”‚  
â”‚  â”œâ”€â”€ Spotify API     â”œâ”€â”€ Ticketmaster  â”œâ”€â”€ Setlist.fm  â”‚  
â”‚  â”œâ”€â”€ Rate Limiting   â”œâ”€â”€ Caching       â”œâ”€â”€ Sync Jobs   â”‚  
â”‚  â””â”€â”€ Error Handling  â””â”€â”€ Data Mapping  â””â”€â”€ Webhooks    â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  External Services                                      â”‚  
â”‚  â”œâ”€â”€ Spotify         â”œâ”€â”€ Ticketmaster  â”œâ”€â”€ Setlist.fm  â”‚  
â”‚  â”œâ”€â”€ Rate: 100/min   â”œâ”€â”€ Rate: Varies  â”œâ”€â”€ Rate: 1/sec â”‚  
â”‚  â””â”€â”€ Auth: OAuth     â””â”€â”€ Auth: API Key â””â”€â”€ Auth: None   â”‚  
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  
\`\`\`

\#\#\# Integration Benefits  
\- \*\*Rich Music Data\*\*: Comprehensive artist information from Spotify  
\- \*\*Live Event Data\*\*: Real-time show and venue information from Ticketmaster  
\- \*\*Historical Setlists\*\*: Community-driven setlist data from Setlist.fm  
\- \*\*Data Enrichment\*\*: Cross-reference data for accuracy and completeness

\#\# Next-Forge External APIs Package

\#\#\# Package Structure  
\`\`\`  
packages/external-apis/  
â”œâ”€â”€ src/  
â”‚   â”œâ”€â”€ clients/  
â”‚   â”‚   â”œâ”€â”€ spotify.ts        \# Spotify API client  
â”‚   â”‚   â”œâ”€â”€ ticketmaster.ts   \# Ticketmaster client  
â”‚   â”‚   â”œâ”€â”€ setlistfm.ts      \# Setlist.fm client  
â”‚   â”‚   â””â”€â”€ base.ts           \# Base client with common features  
â”‚   â”œâ”€â”€ services/  
â”‚   â”‚   â”œâ”€â”€ artist-sync.ts    \# Artist data synchronization  
â”‚   â”‚   â”œâ”€â”€ show-sync.ts      \# Show data synchronization  
â”‚   â”‚   â”œâ”€â”€ venue-sync.ts     \# Venue data synchronization  
â”‚   â”‚   â””â”€â”€ setlist-sync.ts   \# Setlist data synchronization  
â”‚   â”œâ”€â”€ types/  
â”‚   â”‚   â”œâ”€â”€ spotify.ts        \# Spotify API types  
â”‚   â”‚   â”œâ”€â”€ ticketmaster.ts   \# Ticketmaster types  
â”‚   â”‚   â”œâ”€â”€ setlistfm.ts      \# Setlist.fm types  
â”‚   â”‚   â””â”€â”€ common.ts         \# Common API types  
â”‚   â”œâ”€â”€ utils/  
â”‚   â”‚   â”œâ”€â”€ rate-limiter.ts   \# Rate limiting utilities  
â”‚   â”‚   â”œâ”€â”€ cache.ts          \# Caching layer  
â”‚   â”‚   â”œâ”€â”€ mapping.ts        \# Data transformation  
â”‚   â”‚   â””â”€â”€ validation.ts     \# API response validation  
â”‚   â”œâ”€â”€ jobs/  
â”‚   â”‚   â”œâ”€â”€ sync-scheduler.ts \# Scheduled sync jobs  
â”‚   â”‚   â””â”€â”€ queue.ts          \# Job queue management  
â”‚   â””â”€â”€ index.ts              \# Package exports  
â”œâ”€â”€ package.json  
â””â”€â”€ tsconfig.json  
\`\`\`

\#\#\# Base API Client  
\`\`\`typescript  
// packages/external-apis/src/clients/base.ts  
import { Redis } from '@upstash/redis';

export interface APIClientConfig {  
  baseURL: string;  
  apiKey?: string;  
  rateLimit?: {  
    requests: number;  
    window: number; // seconds  
  };  
  cache?: {  
    defaultTTL: number; // seconds  
  };  
}

export abstract class BaseAPIClient {  
  protected baseURL: string;  
  protected apiKey?: string;  
  protected rateLimit?: { requests: number; window: number };  
  protected cache: Redis;

  constructor(config: APIClientConfig) {  
    this.baseURL \= config.baseURL;  
    this.apiKey \= config.apiKey;  
    this.rateLimit \= config.rateLimit;  
    this.cache \= new Redis({  
      url: process.env.UPSTASH\_REDIS\_REST\_URL\!,  
      token: process.env.UPSTASH\_REDIS\_REST\_TOKEN\!,  
    });  
  }

  protected async makeRequest\<T\>(  
    endpoint: string,  
    options: RequestInit \= {},  
    cacheKey?: string,  
    cacheTTL?: number  
  ): Promise\<T\> {  
    // Check cache first  
    if (cacheKey) {  
      const cached \= await this.cache.get(cacheKey);  
      if (cached) {  
        return cached as T;  
      }  
    }

    // Check rate limits  
    if (this.rateLimit) {  
      await this.checkRateLimit();  
    }

    const url \= new URL(endpoint, this.baseURL);  
    const response \= await fetch(url.toString(), {  
      ...options,  
      headers: {  
        'Content-Type': 'application/json',  
        ...this.getAuthHeaders(),  
        ...options.headers,  
      },  
    });

    if (\!response.ok) {  
      throw new APIError(  
        \`API request failed: ${response.status} ${response.statusText}\`,  
        response.status,  
        endpoint  
      );  
    }

    const data \= await response.json();

    // Cache successful responses  
    if (cacheKey && cacheTTL) {  
      await this.cache.setex(cacheKey, cacheTTL, JSON.stringify(data));  
    }

    return data;  
  }

  protected abstract getAuthHeaders(): Record\<string, string\>;

  private async checkRateLimit(): Promise\<void\> {  
    if (\!this.rateLimit) return;

    const key \= \`rate\_limit:${this.constructor.name}\`;  
    const current \= await this.cache.incr(key);  
      
    if (current \=== 1\) {  
      await this.cache.expire(key, this.rateLimit.window);  
    }

    if (current \> this.rateLimit.requests) {  
      const ttl \= await this.cache.ttl(key);  
      throw new RateLimitError(\`Rate limit exceeded. Try again in ${ttl} seconds.\`);  
    }  
  }  
}

export class APIError extends Error {  
  constructor(  
    message: string,  
    public statusCode: number,  
    public endpoint: string  
  ) {  
    super(message);  
    this.name \= 'APIError';  
  }  
}

export class RateLimitError extends Error {  
  constructor(message: string) {  
    super(message);  
    this.name \= 'RateLimitError';  
  }  
}  
\`\`\`

\#\# Spotify API Integration

\#\#\# Spotify Client Implementation  
\`\`\`typescript  
// packages/external-apis/src/clients/spotify.ts  
import { BaseAPIClient, APIClientConfig } from './base';  
import { SpotifyArtist, SpotifyTrack, SpotifySearchResult } from '../types/spotify';

export class SpotifyClient extends BaseAPIClient {  
  private accessToken?: string;

  constructor(config: Omit\<APIClientConfig, 'baseURL'\>) {  
    super({  
      ...config,  
      baseURL: 'https://api.spotify.com/v1',  
      rateLimit: { requests: 100, window: 60 }, // 100 requests per minute  
      cache: { defaultTTL: 3600 }, // 1 hour default cache  
    });  
  }

  async authenticate(): Promise\<void\> {  
    const response \= await fetch('https://accounts.spotify.com/api/token', {  
      method: 'POST',  
      headers: {  
        'Content-Type': 'application/x-www-form-urlencoded',  
        'Authorization': \`Basic ${Buffer.from(  
          \`${process.env.SPOTIFY\_CLIENT\_ID}:${process.env.SPOTIFY\_CLIENT\_SECRET}\`  
        ).toString('base64')}\`,  
      },  
      body: 'grant\_type=client\_credentials',  
    });

    if (\!response.ok) {  
      throw new Error('Spotify authentication failed');  
    }

    const data \= await response.json();  
    this.accessToken \= data.access\_token;  
  }

  protected getAuthHeaders(): Record\<string, string\> {  
    if (\!this.accessToken) {  
      throw new Error('Spotify client not authenticated');  
    }  
    return {  
      'Authorization': \`Bearer ${this.accessToken}\`,  
    };  
  }

  async searchArtists(query: string, limit \= 20): Promise\<SpotifySearchResult\> {  
    const params \= new URLSearchParams({  
      q: query,  
      type: 'artist',  
      limit: limit.toString(),  
    });

    return this.makeRequest\<SpotifySearchResult\>(  
      \`/search?${params}\`,  
      {},  
      \`spotify:search:artists:${query}:${limit}\`,  
      1800 // 30 minutes cache  
    );  
  }

  async getArtist(artistId: string): Promise\<SpotifyArtist\> {  
    return this.makeRequest\<SpotifyArtist\>(  
      \`/artists/${artistId}\`,  
      {},  
      \`spotify:artist:${artistId}\`,  
      3600 // 1 hour cache  
    );  
  }

  async getArtistTopTracks(artistId: string, market \= 'US'): Promise\<{ tracks: SpotifyTrack\[\] }\> {  
    return this.makeRequest\<{ tracks: SpotifyTrack\[\] }\>(  
      \`/artists/${artistId}/top-tracks?market=${market}\`,  
      {},  
      \`spotify:artist:${artistId}:top-tracks:${market}\`,  
      1800 // 30 minutes cache  
    );  
  }

  async getArtistAlbums(artistId: string, options: {  
    include\_groups?: string;  
    market?: string;  
    limit?: number;  
    offset?: number;  
  } \= {}): Promise\<any\> {  
    const params \= new URLSearchParams({  
      include\_groups: options.include\_groups || 'album,single',  
      market: options.market || 'US',  
      limit: (options.limit || 20).toString(),  
      offset: (options.offset || 0).toString(),  
    });

    return this.makeRequest(  
      \`/artists/${artistId}/albums?${params}\`,  
      {},  
      \`spotify:artist:${artistId}:albums:${params.toString()}\`,  
      1800  
    );  
  }

  async getRecommendations(options: {  
    seed\_artists?: string\[\];  
    seed\_genres?: string\[\];  
    limit?: number;  
    market?: string;  
    \[key: string\]: any; // For audio features  
  }): Promise\<{ tracks: SpotifyTrack\[\] }\> {  
    const params \= new URLSearchParams();  
      
    Object.entries(options).forEach((\[key, value\]) \=\> {  
      if (Array.isArray(value)) {  
        params.append(key, value.join(','));  
      } else if (value \!== undefined) {  
        params.append(key, value.toString());  
      }  
    });

    return this.makeRequest\<{ tracks: SpotifyTrack\[\] }\>(  
      \`/recommendations?${params}\`,  
      {},  
      \`spotify:recommendations:${params.toString()}\`,  
      900 // 15 minutes cache for recommendations  
    );  
  }

  async getAudioFeatures(trackIds: string\[\]): Promise\<{ audio\_features: any\[\] }\> {  
    const ids \= trackIds.join(',');  
    return this.makeRequest(  
      \`/audio-features?ids=${ids}\`,  
      {},  
      \`spotify:audio-features:${ids}\`,  
      3600  
    );  
  }  
}  
\`\`\`

\#\#\# Spotify Data Synchronization  
\`\`\`typescript  
// packages/external-apis/src/services/artist-sync.ts  
import { db } from '@repo/database';  
import { artists, songs } from '@repo/database/schema';  
import { SpotifyClient } from '../clients/spotify';  
import { eq } from 'drizzle-orm';

export class ArtistSyncService {  
  private spotifyClient: SpotifyClient;

  constructor() {  
    this.spotifyClient \= new SpotifyClient({});  
  }

  async syncArtist(artistId: string): Promise\<void\> {  
    await this.spotifyClient.authenticate();

    try {  
      // Get artist from Spotify  
      const spotifyArtist \= await this.spotifyClient.getArtist(artistId);  
        
      // Get top tracks  
      const topTracks \= await this.spotifyClient.getArtistTopTracks(artistId);  
        
      // Update or create artist in database  
      await db  
        .insert(artists)  
        .values({  
          spotifyId: spotifyArtist.id,  
          name: spotifyArtist.name,  
          slug: this.generateSlug(spotifyArtist.name),  
          imageUrl: spotifyArtist.images\[0\]?.url,  
          smallImageUrl: spotifyArtist.images\[2\]?.url,  
          genres: JSON.stringify(spotifyArtist.genres),  
          popularity: spotifyArtist.popularity,  
          followers: spotifyArtist.followers.total,  
          externalUrls: JSON.stringify(spotifyArtist.external\_urls),  
          lastSyncedAt: new Date(),  
        })  
        .onConflictDoUpdate({  
          target: artists.spotifyId,  
          set: {  
            name: spotifyArtist.name,  
            imageUrl: spotifyArtist.images\[0\]?.url,  
            smallImageUrl: spotifyArtist.images\[2\]?.url,  
            genres: JSON.stringify(spotifyArtist.genres),  
            popularity: spotifyArtist.popularity,  
            followers: spotifyArtist.followers.total,  
            lastSyncedAt: new Date(),  
          },  
        });

      // Sync top tracks  
      await this.syncArtistTracks(artistId, topTracks.tracks);

    } catch (error) {  
      console.error(\`Failed to sync artist ${artistId}:\`, error);  
      throw error;  
    }  
  }

  private async syncArtistTracks(artistId: string, tracks: SpotifyTrack\[\]): Promise\<void\> {  
    const artist \= await db.query.artists.findFirst({  
      where: eq(artists.spotifyId, artistId),  
    });

    if (\!artist) return;

    for (const track of tracks) {  
      await db  
        .insert(songs)  
        .values({  
          spotifyId: track.id,  
          title: track.name,  
          artist: track.artists\[0\].name,  
          album: track.album.name,  
          albumArtUrl: track.album.images\[0\]?.url,  
          releaseDate: new Date(track.album.release\_date),  
          durationMs: track.duration\_ms,  
          popularity: track.popularity,  
          previewUrl: track.preview\_url,  
          isExplicit: track.explicit,  
          isPlayable: track.is\_playable,  
        })  
        .onConflictDoUpdate({  
          target: songs.spotifyId,  
          set: {  
            title: track.name,  
            popularity: track.popularity,  
            isPlayable: track.is\_playable,  
          },  
        });  
    }  
  }

  private generateSlug(name: string): string {  
    return name  
      .toLowerCase()  
      .replace(/\[^a-z0-9\]+/g, '-')  
      .replace(/(^-|-$)/g, '');  
  }  
}  
\`\`\`

\#\# Ticketmaster API Integration

\#\#\# Ticketmaster Client  
\`\`\`typescript  
// packages/external-apis/src/clients/ticketmaster.ts  
import { BaseAPIClient, APIClientConfig } from './base';  
import { TicketmasterEvent, TicketmasterVenue } from '../types/ticketmaster';

export class TicketmasterClient extends BaseAPIClient {  
  constructor(config: Omit\<APIClientConfig, 'baseURL'\>) {  
    super({  
      ...config,  
      baseURL: 'https://app.ticketmaster.com/discovery/v2',  
      rateLimit: { requests: 5000, window: 24 \* 3600 }, // 5000 requests per day  
      cache: { defaultTTL: 1800 }, // 30 minutes default cache  
    });  
  }

  protected getAuthHeaders(): Record\<string, string\> {  
    return {  
      'apikey': this.apiKey\!,  
    };  
  }

  async searchEvents(options: {  
    keyword?: string;  
    city?: string;  
    stateCode?: string;  
    countryCode?: string;  
    radius?: number;  
    startDateTime?: string;  
    endDateTime?: string;  
    size?: number;  
    page?: number;  
  }): Promise\<{ \_embedded?: { events: TicketmasterEvent\[\] }; page: any }\> {  
    const params \= new URLSearchParams();  
      
    Object.entries(options).forEach((\[key, value\]) \=\> {  
      if (value \!== undefined) {  
        params.append(key, value.toString());  
      }  
    });

    return this.makeRequest(  
      \`/events.json?${params}\`,  
      {},  
      \`ticketmaster:events:${params.toString()}\`,  
      900 // 15 minutes cache  
    );  
  }

  async getEvent(eventId: string): Promise\<TicketmasterEvent\> {  
    return this.makeRequest\<TicketmasterEvent\>(  
      \`/events/${eventId}.json\`,  
      {},  
      \`ticketmaster:event:${eventId}\`,  
      1800  
    );  
  }

  async searchVenues(options: {  
    keyword?: string;  
    city?: string;  
    stateCode?: string;  
    countryCode?: string;  
    size?: number;  
    page?: number;  
  }): Promise\<{ \_embedded?: { venues: TicketmasterVenue\[\] }; page: any }\> {  
    const params \= new URLSearchParams();  
      
    Object.entries(options).forEach((\[key, value\]) \=\> {  
      if (value \!== undefined) {  
        params.append(key, value.toString());  
      }  
    });

    return this.makeRequest(  
      \`/venues.json?${params}\`,  
      {},  
      \`ticketmaster:venues:${params.toString()}\`,  
      3600  
    );  
  }

  async getVenue(venueId: string): Promise\<TicketmasterVenue\> {  
    return this.makeRequest\<TicketmasterVenue\>(  
      \`/venues/${venueId}.json\`,  
      {},  
      \`ticketmaster:venue:${venueId}\`,  
      3600  
    );  
  }  
}  
\`\`\`

\#\#\# Show Synchronization Service  
\`\`\`typescript  
// packages/external-apis/src/services/show-sync.ts  
import { db } from '@repo/database';  
import { shows, venues, artists } from '@repo/database/schema';  
import { TicketmasterClient } from '../clients/ticketmaster';  
import { eq } from 'drizzle-orm';

export class ShowSyncService {  
  private ticketmasterClient: TicketmasterClient;

  constructor() {  
    this.ticketmasterClient \= new TicketmasterClient({  
      apiKey: process.env.TICKETMASTER\_API\_KEY\!,  
    });  
  }

  async syncUpcomingShows(): Promise\<void\> {  
    try {  
      const now \= new Date();  
      const future \= new Date(Date.now() \+ 365 \* 24 \* 60 \* 60 \* 1000); // 1 year ahead

      const events \= await this.ticketmasterClient.searchEvents({  
        startDateTime: now.toISOString(),  
        endDateTime: future.toISOString(),  
        size: 200,  
        countryCode: 'US',  
      });

      if (events.\_embedded?.events) {  
        for (const event of events.\_embedded.events) {  
          await this.syncShow(event);  
        }  
      }  
    } catch (error) {  
      console.error('Failed to sync upcoming shows:', error);  
      throw error;  
    }  
  }

  private async syncShow(tmEvent: TicketmasterEvent): Promise\<void\> {  
    try {  
      // Sync venue first  
      let venue \= null;  
      if (tmEvent.\_embedded?.venues?.\[0\]) {  
        venue \= await this.syncVenue(tmEvent.\_embedded.venues\[0\]);  
      }

      // Find or create artist  
      let artist \= await this.findOrCreateArtist(tmEvent);

      // Create or update show  
      const showData \= {  
        ticketmasterId: tmEvent.id,  
        headlinerArtistId: artist.id,  
        venueId: venue?.id,  
        name: tmEvent.name,  
        slug: this.generateSlug(tmEvent.name),  
        date: new Date(tmEvent.dates.start.localDate),  
        startTime: tmEvent.dates.start.localTime || null,  
        status: this.mapEventStatus(tmEvent.dates.status.code),  
        ticketUrl: tmEvent.url,  
        minPrice: tmEvent.priceRanges?.\[0\]?.min,  
        maxPrice: tmEvent.priceRanges?.\[0\]?.max,  
        currency: tmEvent.priceRanges?.\[0\]?.currency || 'USD',  
      };

      await db  
        .insert(shows)  
        .values(showData)  
        .onConflictDoUpdate({  
          target: shows.ticketmasterId,  
          set: {  
            ...showData,  
            updatedAt: new Date(),  
          },  
        });

    } catch (error) {  
      console.error(\`Failed to sync show ${tmEvent.id}:\`, error);  
    }  
  }

  private async syncVenue(tmVenue: TicketmasterVenue): Promise\<any\> {  
    const venueData \= {  
      ticketmasterId: tmVenue.id,  
      name: tmVenue.name,  
      slug: this.generateSlug(tmVenue.name),  
      address: tmVenue.address?.line1,  
      city: tmVenue.city?.name,  
      state: tmVenue.state?.stateCode,  
      country: tmVenue.country?.countryCode,  
      postalCode: tmVenue.postalCode,  
      latitude: tmVenue.location?.latitude ? parseFloat(tmVenue.location.latitude) : null,  
      longitude: tmVenue.location?.longitude ? parseFloat(tmVenue.location.longitude) : null,  
      timezone: tmVenue.timezone,  
      capacity: tmVenue.capacity,  
      website: tmVenue.url,  
    };

    const \[venue\] \= await db  
      .insert(venues)  
      .values(venueData)  
      .onConflictDoUpdate({  
        target: venues.ticketmasterId,  
        set: venueData,  
      })  
      .returning();

    return venue;  
  }

  private async findOrCreateArtist(tmEvent: TicketmasterEvent): Promise\<any\> {  
    const attractionName \= tmEvent.\_embedded?.attractions?.\[0\]?.name || tmEvent.name;  
      
    let artist \= await db.query.artists.findFirst({  
      where: eq(artists.name, attractionName),  
    });

    if (\!artist) {  
      const \[newArtist\] \= await db  
        .insert(artists)  
        .values({  
          name: attractionName,  
          slug: this.generateSlug(attractionName),  
          verified: false,  
        })  
        .returning();  
        
      artist \= newArtist;  
    }

    return artist;  
  }

  private mapEventStatus(statusCode: string): 'upcoming' | 'cancelled' | 'completed' {  
    switch (statusCode) {  
      case 'onsale':  
      case 'offsale':  
        return 'upcoming';  
      case 'cancelled':  
        return 'cancelled';  
      default:  
        return 'upcoming';  
    }  
  }

  private generateSlug(name: string): string {  
    return name  
      .toLowerCase()  
      .replace(/\[^a-z0-9\]+/g, '-')  
      .replace(/(^-|-$)/g, '');  
  }  
}  
\`\`\`

\#\# Setlist.fm API Integration

\#\#\# Setlist.fm Client  
\`\`\`typescript  
// packages/external-apis/src/clients/setlistfm.ts  
import { BaseAPIClient, APIClientConfig } from './base';  
import { SetlistFmSetlist } from '../types/setlistfm';

export class SetlistFmClient extends BaseAPIClient {  
  constructor(config: Omit\<APIClientConfig, 'baseURL'\>) {  
    super({  
      ...config,  
      baseURL: 'https://api.setlist.fm/rest/1.0',  
      rateLimit: { requests: 60, window: 60 }, // 1 request per second  
      cache: { defaultTTL: 3600 }, // 1 hour cache  
    });  
  }

  protected getAuthHeaders(): Record\<string, string\> {  
    return {  
      'x-api-key': this.apiKey\!,  
      'Accept': 'application/json',  
    };  
  }

  async searchSetlists(options: {  
    artistName?: string;  
    artistMbid?: string;  
    venueName?: string;  
    cityName?: string;  
    date?: string;  
    year?: number;  
    p?: number; // page  
  }): Promise\<{ setlist: SetlistFmSetlist\[\] }\> {  
    const params \= new URLSearchParams();  
      
    Object.entries(options).forEach((\[key, value\]) \=\> {  
      if (value \!== undefined) {  
        params.append(key, value.toString());  
      }  
    });

    return this.makeRequest(  
      \`/search/setlists?${params}\`,  
      {},  
      \`setlistfm:search:${params.toString()}\`,  
      1800  
    );  
  }

  async getSetlist(setlistId: string): Promise\<SetlistFmSetlist\> {  
    return this.makeRequest\<SetlistFmSetlist\>(  
      \`/setlist/${setlistId}\`,  
      {},  
      \`setlistfm:setlist:${setlistId}\`,  
      3600  
    );  
  }

  async getArtistSetlists(artistMbid: string, page \= 1): Promise\<{ setlist: SetlistFmSetlist\[\] }\> {  
    return this.makeRequest(  
      \`/artist/${artistMbid}/setlists?p=${page}\`,  
      {},  
      \`setlistfm:artist:${artistMbid}:setlists:${page}\`,  
      1800  
    );  
  }

  async getVenueSetlists(venueId: string, page \= 1): Promise\<{ setlist: SetlistFmSetlist\[\] }\> {  
    return this.makeRequest(  
      \`/venue/${venueId}/setlists?p=${page}\`,  
      {},  
      \`setlistfm:venue:${venueId}:setlists:${page}\`,  
      1800  
    );  
  }  
}  
\`\`\`

\#\# Data Synchronization Strategy

\#\#\# Sync Scheduler  
\`\`\`typescript  
// packages/external-apis/src/jobs/sync-scheduler.ts  
import { CronJob } from 'cron';  
import { ArtistSyncService } from '../services/artist-sync';  
import { ShowSyncService } from '../services/show-sync';  
import { SetlistSyncService } from '../services/setlist-sync';

export class SyncScheduler {  
  private artistSync: ArtistSyncService;  
  private showSync: ShowSyncService;  
  private setlistSync: SetlistSyncService;

  constructor() {  
    this.artistSync \= new ArtistSyncService();  
    this.showSync \= new ShowSyncService();  
    this.setlistSync \= new SetlistSyncService();  
  }

  startScheduler(): void {  
    // Sync upcoming shows every hour  
    new CronJob('0 \* \* \* \*', async () \=\> {  
      console.log('Starting show sync...');  
      try {  
        await this.showSync.syncUpcomingShows();  
        console.log('Show sync completed');  
      } catch (error) {  
        console.error('Show sync failed:', error);  
      }  
    }, null, true);

    // Sync popular artists daily at 2 AM  
    new CronJob('0 2 \* \* \*', async () \=\> {  
      console.log('Starting daily artist sync...');  
      try {  
        await this.artistSync.syncPopularArtists();  
        console.log('Artist sync completed');  
      } catch (error) {  
        console.error('Artist sync failed:', error);  
      }  
    }, null, true);

    // Sync recent setlists every 6 hours  
    new CronJob('0 \*/6 \* \* \*', async () \=\> {  
      console.log('Starting setlist sync...');  
      try {  
        await this.setlistSync.syncRecentSetlists();  
        console.log('Setlist sync completed');  
      } catch (error) {  
        console.error('Setlist sync failed:', error);  
      }  
    }, null, true);

    console.log('Sync scheduler started');  
  }  
}  
\`\`\`

\#\# Rate Limiting & Caching

\#\#\# Advanced Rate Limiter  
\`\`\`typescript  
// packages/external-apis/src/utils/rate-limiter.ts  
import { Redis } from '@upstash/redis';

export class RateLimiter {  
  private redis: Redis;

  constructor() {  
    this.redis \= new Redis({  
      url: process.env.UPSTASH\_REDIS\_REST\_URL\!,  
      token: process.env.UPSTASH\_REDIS\_REST\_TOKEN\!,  
    });  
  }

  async checkLimit(  
    identifier: string,  
    limit: number,  
    windowSeconds: number  
  ): Promise\<{ allowed: boolean; remaining: number; resetTime: number }\> {  
    const key \= \`rate\_limit:${identifier}\`;  
    const now \= Date.now();  
    const window \= windowSeconds \* 1000;

    // Use Redis sorted set for sliding window  
    const pipeline \= this.redis.multi();  
      
    // Remove expired entries  
    pipeline.zremrangebyscore(key, 0, now \- window);  
      
    // Count current requests  
    pipeline.zcard(key);  
      
    // Add current request  
    pipeline.zadd(key, { score: now, member: now });  
      
    // Set expiration  
    pipeline.expire(key, windowSeconds);

    const results \= await pipeline.exec();  
    const currentCount \= results\[1\] as number;

    if (currentCount \>= limit) {  
      return {  
        allowed: false,  
        remaining: 0,  
        resetTime: now \+ window,  
      };  
    }

    return {  
      allowed: true,  
      remaining: limit \- currentCount \- 1,  
      resetTime: now \+ window,  
    };  
  }  
}  
\`\`\`

\#\#\# Intelligent Caching  
\`\`\`typescript  
// packages/external-apis/src/utils/cache.ts  
import { Redis } from '@upstash/redis';

export class IntelligentCache {  
  private redis: Redis;

  constructor() {  
    this.redis \= new Redis({  
      url: process.env.UPSTASH\_REDIS\_REST\_URL\!,  
      token: process.env.UPSTASH\_REDIS\_REST\_TOKEN\!,  
    });  
  }

  async get\<T\>(key: string): Promise\<T | null\> {  
    const data \= await this.redis.get(key);  
    return data as T | null;  
  }

  async set(  
    key: string,  
    data: any,  
    ttlSeconds?: number,  
    options: {  
      refreshThreshold?: number; // Refresh when TTL is below this  
      staleWhileRevalidate?: boolean;  
    } \= {}  
  ): Promise\<void\> {  
    const pipeline \= this.redis.multi();  
      
    pipeline.set(key, JSON.stringify(data));  
      
    if (ttlSeconds) {  
      pipeline.expire(key, ttlSeconds);  
    }

    // Set metadata for intelligent refresh  
    if (options.refreshThreshold) {  
      pipeline.set(\`${key}:meta\`, JSON.stringify({  
        refreshThreshold: options.refreshThreshold,  
        staleWhileRevalidate: options.staleWhileRevalidate,  
        lastUpdated: Date.now(),  
      }));  
      pipeline.expire(\`${key}:meta\`, ttlSeconds || 3600);  
    }

    await pipeline.exec();  
  }

  async shouldRefresh(key: string): Promise\<boolean\> {  
    const \[ttl, meta\] \= await Promise.all(\[  
      this.redis.ttl(key),  
      this.redis.get(\`${key}:meta\`),  
    \]);

    if (\!meta || ttl \=== \-1) return false;

    const metadata \= JSON.parse(meta as string);  
    return ttl \<= metadata.refreshThreshold;  
  }

  async invalidatePattern(pattern: string): Promise\<void\> {  
    // Note: This requires Redis SCAN command which might not be available in all Redis setups  
    // Alternative: maintain key sets for pattern-based invalidation  
    const keys \= await this.redis.keys(pattern);  
    if (keys.length \> 0\) {  
      await this.redis.del(...keys);  
    }  
  }  
}  
\`\`\`

\#\# Error Handling & Resilience

\#\#\# Circuit Breaker Pattern  
\`\`\`typescript  
// packages/external-apis/src/utils/circuit-breaker.ts  
export class CircuitBreaker {  
  private failures \= 0;  
  private nextAttempt \= Date.now();  
  private state: 'CLOSED' | 'OPEN' | 'HALF\_OPEN' \= 'CLOSED';

  constructor(  
    private threshold: number \= 5,  
    private timeout: number \= 60000,  
    private resetTimeout: number \= 300000  
  ) {}

  async execute\<T\>(operation: () \=\> Promise\<T\>): Promise\<T\> {  
    if (this.state \=== 'OPEN') {  
      if (Date.now() \< this.nextAttempt) {  
        throw new Error('Circuit breaker is OPEN');  
      }  
      this.state \= 'HALF\_OPEN';  
    }

    try {  
      const result \= await operation();  
      this.onSuccess();  
      return result;  
    } catch (error) {  
      this.onFailure();  
      throw error;  
    }  
  }

  private onSuccess(): void {  
    this.failures \= 0;  
    this.state \= 'CLOSED';  
  }

  private onFailure(): void {  
    this.failures++;  
    if (this.failures \>= this.threshold) {  
      this.state \= 'OPEN';  
      this.nextAttempt \= Date.now() \+ this.resetTimeout;  
    }  
  }

  getState(): string {  
    return this.state;  
  }  
}  
\`\`\`

This comprehensive API integration system provides robust, scalable access to external music data while maintaining performance and reliability through intelligent caching, rate limiting, and error handling strategies.

\# MySetlist \- Deployment, Monitoring & Production

\#\# Table of Contents  
1\. \[Deployment Architecture\](\#deployment-architecture)  
2\. \[Next-Forge Production Setup\](\#next-forge-production-setup)  
3\. \[Vercel Deployment Configuration\](\#vercel-deployment-configuration)  
4\. \[Environment Management\](\#environment-management)  
5\. \[Database Management & Migrations\](\#database-management--migrations)  
6\. \[Monitoring & Analytics\](\#monitoring--analytics)  
7\. \[Performance Optimization\](\#performance-optimization)  
8\. \[Security & Compliance\](\#security--compliance)  
9\. \[Backup & Disaster Recovery\](\#backup--disaster-recovery)  
10\. \[Development Workflow\](\#development-workflow)

\#\# Deployment Architecture

MySetlist leverages Next-Forge's production-ready deployment strategy with Vercel for frontend hosting, Supabase for backend services, and additional monitoring tools for production reliability.

\#\#\# Production Infrastructure  
\`\`\`  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚                    Production Stack                      â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  Frontend (Vercel)         â”‚  Backend Services           â”‚  
â”‚  â”œâ”€â”€ Next.js App          â”‚  â”œâ”€â”€ Supabase (PostgreSQL) â”‚  
â”‚  â”œâ”€â”€ Edge Functions       â”‚  â”œâ”€â”€ Supabase Auth         â”‚  
â”‚  â”œâ”€â”€ API Routes          â”‚  â”œâ”€â”€ Supabase Realtime     â”‚  
â”‚  â””â”€â”€ Static Assets       â”‚  â””â”€â”€ Supabase Storage      â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  External Services         â”‚  Monitoring & Tools         â”‚  
â”‚  â”œâ”€â”€ Upstash Redis       â”‚  â”œâ”€â”€ Vercel Analytics      â”‚  
â”‚  â”œâ”€â”€ Resend Email        â”‚  â”œâ”€â”€ Sentry Error Tracking â”‚  
â”‚  â”œâ”€â”€ Spotify API         â”‚  â”œâ”€â”€ LogTail Logging       â”‚  
â”‚  â””â”€â”€ Ticketmaster API    â”‚  â””â”€â”€ Uptime Monitoring     â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  CDN & Edge               â”‚  Security & Compliance      â”‚  
â”‚  â”œâ”€â”€ Vercel Edge Network â”‚  â”œâ”€â”€ SSL/TLS Certificates  â”‚  
â”‚  â”œâ”€â”€ Image Optimization  â”‚  â”œâ”€â”€ GDPR Compliance       â”‚  
â”‚  â””â”€â”€ Geo-distribution    â”‚  â””â”€â”€ Data Protection       â”‚  
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  
\`\`\`

\#\#\# Deployment Environments  
\- \*\*Development\*\*: Local development with hot reload  
\- \*\*Preview\*\*: Branch-based preview deployments on Vercel  
\- \*\*Staging\*\*: Production-like environment for testing  
\- \*\*Production\*\*: Live application serving users

\#\# Next-Forge Production Setup

\#\#\# Project Configuration  
\`\`\`typescript  
// next.config.js  
/\*\* @type {import('next').NextConfig} \*/  
const nextConfig \= {  
  // Performance optimizations  
  experimental: {  
    optimizePackageImports: \['@repo/ui', '@repo/database'\],  
    turbo: {  
      rules: {  
        '\*.svg': {  
          loaders: \['@svgr/webpack'\],  
          as: '\*.js',  
        },  
      },  
    },  
  },

  // Image optimization  
  images: {  
    domains: \[  
      'i.scdn.co', // Spotify images  
      's1.ticketm.net', // Ticketmaster images  
      'images.unsplash.com', // Placeholder images  
    \],  
    formats: \['image/webp', 'image/avif'\],  
  },

  // Security headers  
  async headers() {  
    return \[  
      {  
        source: '/(.\*)',  
        headers: \[  
          {  
            key: 'X-Frame-Options',  
            value: 'DENY',  
          },  
          {  
            key: 'X-Content-Type-Options',  
            value: 'nosniff',  
          },  
          {  
            key: 'Referrer-Policy',  
            value: 'origin-when-cross-origin',  
          },  
          {  
            key: 'Permissions-Policy',  
            value: 'camera=(), microphone=(), geolocation=(self)',  
          },  
        \],  
      },  
    \];  
  },

  // Redirects and rewrites  
  async redirects() {  
    return \[  
      {  
        source: '/login',  
        destination: '/auth/signin',  
        permanent: true,  
      },  
      {  
        source: '/register',  
        destination: '/auth/signup',  
        permanent: true,  
      },  
    \];  
  },

  // Bundle analyzer  
  ...(process.env.ANALYZE \=== 'true' && {  
    webpack: (config) \=\> {  
      config.plugins.push(  
        new (require('webpack-bundle-analyzer').BundleAnalyzerPlugin)({  
          analyzerMode: 'server',  
          openAnalyzer: true,  
        })  
      );  
      return config;  
    },  
  }),  
};

module.exports \= nextConfig;  
\`\`\`

\#\#\# Package Scripts  
\`\`\`json  
// apps/web/package.json  
{  
  "scripts": {  
    "dev": "next dev",  
    "build": "next build",  
    "start": "next start",  
    "lint": "next lint",  
    "type-check": "tsc \--noEmit",  
    "test": "jest",  
    "test:e2e": "playwright test",  
    "analyze": "ANALYZE=true npm run build",  
    "db:generate": "cd ../../packages/database && npm run generate",  
    "db:migrate": "cd ../../packages/database && npm run migrate",  
    "db:seed": "cd ../../packages/database && npm run seed"  
  }  
}  
\`\`\`

\#\# Vercel Deployment Configuration

\#\#\# Vercel Configuration  
\`\`\`json  
// vercel.json  
{  
  "buildCommand": "npm run build",  
  "outputDirectory": ".next",  
  "installCommand": "npm install",  
  "framework": "nextjs",  
  "functions": {  
    "app/api/sync/\*\*": {  
      "maxDuration": 60  
    },  
    "app/api/search/\*\*": {  
      "maxDuration": 30  
    }  
  },  
  "headers": \[  
    {  
      "source": "/api/(.\*)",  
      "headers": \[  
        {  
          "key": "Cache-Control",  
          "value": "s-maxage=0, stale-while-revalidate"  
        }  
      \]  
    },  
    {  
      "source": "/(.\*)",  
      "headers": \[  
        {  
          "key": "X-Content-Type-Options",  
          "value": "nosniff"  
        },  
        {  
          "key": "X-Frame-Options",  
          "value": "DENY"  
        },  
        {  
          "key": "X-XSS-Protection",  
          "value": "1; mode=block"  
        }  
      \]  
    }  
  \],  
  "rewrites": \[  
    {  
      "source": "/api/webhooks/(.\*)",  
      "destination": "/api/webhooks/$1"  
    }  
  \]  
}  
\`\`\`

\#\#\# Environment Variables Setup  
\`\`\`bash  
\# .env.example  
\# App Configuration  
NEXT\_PUBLIC\_APP\_URL=https://MySetlist.app  
NEXT\_PUBLIC\_APP\_ENV=production

\# Supabase  
NEXT\_PUBLIC\_SUPABASE\_URL=https://your-project.supabase.co  
NEXT\_PUBLIC\_SUPABASE\_ANON\_KEY=your\_anon\_key  
SUPABASE\_SERVICE\_ROLE\_KEY=your\_service\_role\_key  
DATABASE\_URL=postgresql://postgres:\[password\]@db.\[ref\].supabase.co:5432/postgres

\# External APIs  
SPOTIFY\_CLIENT\_ID=your\_spotify\_client\_id  
SPOTIFY\_CLIENT\_SECRET=your\_spotify\_client\_secret  
TICKETMASTER\_API\_KEY=your\_ticketmaster\_api\_key  
SETLISTFM\_API\_KEY=your\_setlistfm\_api\_key

\# Services  
UPSTASH\_REDIS\_REST\_URL=https://your-redis.upstash.io  
UPSTASH\_REDIS\_REST\_TOKEN=your\_redis\_token  
RESEND\_API\_KEY=your\_resend\_api\_key

\# Monitoring  
SENTRY\_DSN=https://your-sentry-dsn@sentry.io/project  
SENTRY\_AUTH\_TOKEN=your\_sentry\_auth\_token  
NEXT\_PUBLIC\_POSTHOG\_KEY=your\_posthog\_key  
NEXT\_PUBLIC\_POSTHOG\_HOST=https://app.posthog.com  
\`\`\`

\#\# Environment Management

\#\#\# Environment-Specific Configurations  
\`\`\`typescript  
// lib/config.ts  
const config \= {  
  app: {  
    name: 'MySetlist',  
    url: process.env.NEXT\_PUBLIC\_APP\_URL\!,  
    env: process.env.NEXT\_PUBLIC\_APP\_ENV as 'development' | 'staging' | 'production',  
  },  
    
  supabase: {  
    url: process.env.NEXT\_PUBLIC\_SUPABASE\_URL\!,  
    anonKey: process.env.NEXT\_PUBLIC\_SUPABASE\_ANON\_KEY\!,  
    serviceRoleKey: process.env.SUPABASE\_SERVICE\_ROLE\_KEY\!,  
  },

  apis: {  
    spotify: {  
      clientId: process.env.SPOTIFY\_CLIENT\_ID\!,  
      clientSecret: process.env.SPOTIFY\_CLIENT\_SECRET\!,  
    },  
    ticketmaster: {  
      apiKey: process.env.TICKETMASTER\_API\_KEY\!,  
    },  
    setlistfm: {  
      apiKey: process.env.SETLISTFM\_API\_KEY\!,  
    },  
  },

  redis: {  
    url: process.env.UPSTASH\_REDIS\_REST\_URL\!,  
    token: process.env.UPSTASH\_REDIS\_REST\_TOKEN\!,  
  },

  monitoring: {  
    sentry: {  
      dsn: process.env.SENTRY\_DSN\!,  
    },  
    posthog: {  
      key: process.env.NEXT\_PUBLIC\_POSTHOG\_KEY\!,  
      host: process.env.NEXT\_PUBLIC\_POSTHOG\_HOST\!,  
    },  
  },

  features: {  
    enableAnalytics: config.app.env \=== 'production',  
    enableDebugLogs: config.app.env \!== 'production',  
    enableExperimentalFeatures: config.app.env \=== 'development',  
  },  
} as const;

export default config;  
\`\`\`

\#\#\# Feature Flags  
\`\`\`typescript  
// lib/feature-flags.ts  
export const FEATURE\_FLAGS \= {  
  SPOTIFY\_INTEGRATION: process.env.NEXT\_PUBLIC\_ENABLE\_SPOTIFY \=== 'true',  
  REAL\_TIME\_UPDATES: process.env.NEXT\_PUBLIC\_ENABLE\_REALTIME \=== 'true',  
  PUSH\_NOTIFICATIONS: process.env.NEXT\_PUBLIC\_ENABLE\_PUSH \=== 'true',  
  ADVANCED\_SEARCH: process.env.NEXT\_PUBLIC\_ENABLE\_ADVANCED\_SEARCH \=== 'true',  
  USER\_GENERATED\_CONTENT: process.env.NEXT\_PUBLIC\_ENABLE\_UGC \=== 'true',  
} as const;

export function isFeatureEnabled(flag: keyof typeof FEATURE\_FLAGS): boolean {  
  return FEATURE\_FLAGS\[flag\] ?? false;  
}  
\`\`\`

\#\# Database Management & Migrations

\#\#\# Production Migration Strategy  
\`\`\`typescript  
// packages/database/src/migrate-production.ts  
import { migrate } from 'drizzle-orm/postgres-js/migrator';  
import { db, migrationClient } from './client';  
import { sql } from 'drizzle-orm';

async function runProductionMigrations() {  
  console.log('ğŸš€ Starting production migrations...');  
    
  try {  
    // Check if database is accessible  
    await db.execute(sql\`SELECT 1\`);  
    console.log('âœ… Database connection established');

    // Run migrations with transaction  
    await migrationClient.begin(async (tx) \=\> {  
      await migrate(db, {   
        migrationsFolder: './migrations',  
        migrationsTable: 'drizzle\_migrations',  
      });  
    });

    console.log('âœ… Migrations completed successfully');  
  } catch (error) {  
    console.error('âŒ Migration failed:', error);  
    process.exit(1);  
  } finally {  
    await migrationClient.end();  
  }  
}

// Only run if called directly  
if (require.main \=== module) {  
  runProductionMigrations();  
}  
\`\`\`

\#\#\# Database Backup Automation  
\`\`\`typescript  
// scripts/backup-database.ts  
import { exec } from 'child\_process';  
import { promisify } from 'util';

const execAsync \= promisify(exec);

async function backupDatabase() {  
  const timestamp \= new Date().toISOString().split('T')\[0\];  
  const backupName \= \`MySetlist-backup-${timestamp}.sql\`;  
    
  try {  
    console.log('ğŸ”„ Starting database backup...');  
      
    const command \= \`pg\_dump ${process.env.DATABASE\_URL} \> backups/${backupName}\`;  
    await execAsync(command);  
      
    console.log(\`âœ… Backup created: ${backupName}\`);  
      
    // Upload to cloud storage (implementation depends on provider)  
    await uploadToCloudStorage(backupName);  
      
  } catch (error) {  
    console.error('âŒ Backup failed:', error);  
    // Send alert notification  
    await sendBackupAlert(error);  
  }  
}

async function uploadToCloudStorage(filename: string) {  
  // Implementation for cloud storage upload  
  // Could use AWS S3, Google Cloud Storage, etc.  
}

async function sendBackupAlert(error: Error) {  
  // Send notification to team about backup failure  
}

// Schedule daily backups  
if (process.env.NODE\_ENV \=== 'production') {  
  setInterval(backupDatabase, 24 \* 60 \* 60 \* 1000); // Daily  
}  
\`\`\`

\#\# Monitoring & Analytics

\#\#\# Error Tracking with Sentry  
\`\`\`typescript  
// lib/sentry.ts  
import \* as Sentry from '@sentry/nextjs';

const SENTRY\_DSN \= process.env.SENTRY\_DSN;

Sentry.init({  
  dsn: SENTRY\_DSN,  
  environment: process.env.NEXT\_PUBLIC\_APP\_ENV,  
  tracesSampleRate: process.env.NODE\_ENV \=== 'production' ? 0.1 : 1.0,  
  debug: process.env.NODE\_ENV \=== 'development',  
    
  beforeSend(event) {  
    // Filter out known non-critical errors  
    if (event.exception) {  
      const error \= event.exception.values?.\[0\];  
      if (error?.type \=== 'ChunkLoadError') {  
        return null; // Don't send chunk load errors  
      }  
    }  
    return event;  
  },

  integrations: \[  
    new Sentry.BrowserTracing({  
      tracingOrigins: \['localhost', 'MySetlist.app'\],  
    }),  
  \],  
});

export { Sentry };  
\`\`\`

\#\#\# Application Metrics  
\`\`\`typescript  
// lib/metrics.ts  
import { PostHog } from 'posthog-node';

class MetricsService {  
  private posthog: PostHog;

  constructor() {  
    this.posthog \= new PostHog(  
      process.env.NEXT\_PUBLIC\_POSTHOG\_KEY\!,  
      {  
        host: process.env.NEXT\_PUBLIC\_POSTHOG\_HOST,  
      }  
    );  
  }

  trackEvent(  
    userId: string | null,  
    event: string,  
    properties?: Record\<string, any\>  
  ) {  
    if (process.env.NODE\_ENV \!== 'production') return;

    this.posthog.capture({  
      distinctId: userId || 'anonymous',  
      event,  
      properties: {  
        ...properties,  
        timestamp: new Date().toISOString(),  
        environment: process.env.NEXT\_PUBLIC\_APP\_ENV,  
      },  
    });  
  }

  trackPageView(userId: string | null, path: string) {  
    this.trackEvent(userId, '$pageview', { path });  
  }

  trackUserAction(userId: string, action: string, data?: Record\<string, any\>) {  
    this.trackEvent(userId, \`user\_${action}\`, data);  
  }

  trackAPICall(endpoint: string, duration: number, status: number) {  
    this.trackEvent(null, 'api\_call', {  
      endpoint,  
      duration,  
      status,  
    });  
  }

  async shutdown() {  
    await this.posthog.shutdown();  
  }  
}

export const metrics \= new MetricsService();  
\`\`\`

\#\#\# Performance Monitoring  
\`\`\`typescript  
// lib/performance.ts  
export class PerformanceMonitor {  
  static measureAsyncOperation\<T\>(  
    operation: () \=\> Promise\<T\>,  
    operationName: string  
  ): Promise\<T\> {  
    return new Promise(async (resolve, reject) \=\> {  
      const startTime \= performance.now();  
        
      try {  
        const result \= await operation();  
        const endTime \= performance.now();  
        const duration \= endTime \- startTime;  
          
        console.log(\`â±ï¸ ${operationName} took ${duration.toFixed(2)}ms\`);  
          
        // Track in analytics  
        metrics.trackEvent(null, 'performance\_metric', {  
          operation: operationName,  
          duration: Math.round(duration),  
        });  
          
        resolve(result);  
      } catch (error) {  
        const endTime \= performance.now();  
        const duration \= endTime \- startTime;  
          
        console.error(\`âŒ ${operationName} failed after ${duration.toFixed(2)}ms:\`, error);  
          
        metrics.trackEvent(null, 'performance\_error', {  
          operation: operationName,  
          duration: Math.round(duration),  
          error: error.message,  
        });  
          
        reject(error);  
      }  
    });  
  }

  static measurePageLoad() {  
    if (typeof window \=== 'undefined') return;

    window.addEventListener('load', () \=\> {  
      const navigation \= performance.getEntriesByType('navigation')\[0\] as PerformanceNavigationTiming;  
        
      const pageLoadTime \= navigation.loadEventEnd \- navigation.fetchStart;  
      const dnsTime \= navigation.domainLookupEnd \- navigation.domainLookupStart;  
      const tcpTime \= navigation.connectEnd \- navigation.connectStart;  
      const ttfb \= navigation.responseStart \- navigation.requestStart;  
        
      metrics.trackEvent(null, 'page\_performance', {  
        pageLoadTime: Math.round(pageLoadTime),  
        dnsTime: Math.round(dnsTime),  
        tcpTime: Math.round(tcpTime),  
        ttfb: Math.round(ttfb),  
        path: window.location.pathname,  
      });  
    });  
  }  
}  
\`\`\`

\#\# Performance Optimization

\#\#\# Caching Strategy  
\`\`\`typescript  
// lib/cache-control.ts  
export const CACHE\_STRATEGIES \= {  
  // Static content \- cache for 1 year with revalidation  
  STATIC: 'public, max-age=31536000, immutable',  
    
  // API responses \- cache for 5 minutes  
  API\_SHORT: 'public, max-age=300, stale-while-revalidate=3600',  
    
  // Artist/venue data \- cache for 1 hour  
  CONTENT\_MEDIUM: 'public, max-age=3600, stale-while-revalidate=86400',  
    
  // Search results \- cache for 10 minutes  
  SEARCH: 'public, max-age=600, stale-while-revalidate=1800',  
    
  // User-specific content \- no cache  
  PRIVATE: 'private, no-cache, no-store, must-revalidate',  
    
  // Real-time data \- minimal cache  
  REALTIME: 'public, max-age=60, stale-while-revalidate=300',  
} as const;

export function setCacheHeaders(  
  response: Response,  
  strategy: keyof typeof CACHE\_STRATEGIES  
): Response {  
  response.headers.set('Cache-Control', CACHE\_STRATEGIES\[strategy\]);  
  return response;  
}  
\`\`\`

\#\#\# Image Optimization  
\`\`\`typescript  
// components/optimized-image.tsx  
import Image from 'next/image';  
import { useState } from 'react';

interface OptimizedImageProps {  
  src: string;  
  alt: string;  
  width?: number;  
  height?: number;  
  className?: string;  
  priority?: boolean;  
  placeholder?: 'blur' | 'empty';  
}

export function OptimizedImage({  
  src,  
  alt,  
  width \= 400,  
  height \= 400,  
  className,  
  priority \= false,  
  placeholder \= 'empty',  
}: OptimizedImageProps) {  
  const \[isLoading, setIsLoading\] \= useState(true);  
  const \[hasError, setHasError\] \= useState(false);

  return (  
    \<div className={\`relative overflow-hidden ${className}\`}\>  
      {\!hasError ? (  
        \<Image  
          src={src}  
          alt={alt}  
          width={width}  
          height={height}  
          priority={priority}  
          placeholder={placeholder}  
          className={\`transition-opacity duration-300 ${  
            isLoading ? 'opacity-0' : 'opacity-100'  
          }\`}  
          onLoadingComplete={() \=\> setIsLoading(false)}  
          onError={() \=\> {  
            setHasError(true);  
            setIsLoading(false);  
          }}  
          sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"  
        /\>  
      ) : (  
        \<div className="flex items-center justify-center bg-muted h-full"\>  
          \<span className="text-muted-foreground"\>Image unavailable\</span\>  
        \</div\>  
      )}  
        
      {isLoading && (  
        \<div className="absolute inset-0 bg-muted animate-pulse" /\>  
      )}  
    \</div\>  
  );  
}  
\`\`\`

\#\# Security & Compliance

\#\#\# Security Headers Middleware  
\`\`\`typescript  
// middleware.ts  
import { NextResponse } from 'next/server';  
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {  
  const response \= NextResponse.next();

  // Security headers  
  response.headers.set('X-DNS-Prefetch-Control', 'on');  
  response.headers.set('Strict-Transport-Security', 'max-age=63072000; includeSubDomains; preload');  
  response.headers.set('X-XSS-Protection', '1; mode=block');  
  response.headers.set('X-Frame-Options', 'SAMEORIGIN');  
  response.headers.set('X-Content-Type-Options', 'nosniff');  
  response.headers.set('Referrer-Policy', 'origin-when-cross-origin');  
    
  // CSP Header  
  const cspHeader \= \`  
    default-src 'self';  
    script-src 'self' 'unsafe-eval' 'unsafe-inline' \*.vercel.app \*.posthog.com;  
    style-src 'self' 'unsafe-inline';  
    img-src 'self' blob: data: https:;  
    font-src 'self';  
    object-src 'none';  
    base-uri 'self';  
    form-action 'self';  
    frame-ancestors 'none';  
    upgrade-insecure-requests;  
  \`.replace(/\\s{2,}/g, ' ').trim();  
    
  response.headers.set('Content-Security-Policy', cspHeader);

  return response;  
}

export const config \= {  
  matcher: \[  
    '/((?\!api|\_next/static|\_next/image|favicon.ico).\*)',  
  \],  
};  
\`\`\`

\#\#\# GDPR Compliance  
\`\`\`typescript  
// components/cookie-consent.tsx  
'use client';

import { useState, useEffect } from 'react';  
import { Button } from '@repo/ui/components/button';  
import { Card } from '@repo/ui/components/card';

export function CookieConsent() {  
  const \[showBanner, setShowBanner\] \= useState(false);

  useEffect(() \=\> {  
    const consent \= localStorage.getItem('cookie-consent');  
    if (\!consent) {  
      setShowBanner(true);  
    }  
  }, \[\]);

  const acceptCookies \= () \=\> {  
    localStorage.setItem('cookie-consent', 'accepted');  
    setShowBanner(false);  
      
    // Initialize analytics after consent  
    if (typeof window \!== 'undefined') {  
      window.gtag?.('consent', 'update', {  
        analytics\_storage: 'granted',  
        ad\_storage: 'granted',  
      });  
    }  
  };

  const declineCookies \= () \=\> {  
    localStorage.setItem('cookie-consent', 'declined');  
    setShowBanner(false);  
  };

  if (\!showBanner) return null;

  return (  
    \<div className="fixed bottom-4 left-4 right-4 z-50 max-w-md mx-auto"\>  
      \<Card className="p-4 shadow-lg"\>  
        \<h3 className="font-semibold mb-2"\>Cookie Consent\</h3\>  
        \<p className="text-sm text-muted-foreground mb-4"\>  
          We use cookies to enhance your experience and analyze our traffic.   
          By clicking "Accept", you consent to our use of cookies.  
        \</p\>  
        \<div className="flex gap-2"\>  
          \<Button onClick={acceptCookies} size="sm"\>  
            Accept  
          \</Button\>  
          \<Button onClick={declineCookies} variant="outline" size="sm"\>  
            Decline  
          \</Button\>  
        \</div\>  
      \</Card\>  
    \</div\>  
  );  
}  
\`\`\`

\#\# Backup & Disaster Recovery

\#\#\# Automated Backup System  
\`\`\`typescript  
// scripts/disaster-recovery.ts  
import { exec } from 'child\_process';  
import { promisify } from 'util';

const execAsync \= promisify(exec);

export class DisasterRecoveryService {  
  async createFullBackup(): Promise\<void\> {  
    const timestamp \= new Date().toISOString();  
    const backupName \= \`full-backup-${timestamp}\`;

    try {  
      // Database backup  
      await this.backupDatabase(backupName);  
        
      // File storage backup  
      await this.backupStorage(backupName);  
        
      // Configuration backup  
      await this.backupConfiguration(backupName);  
        
      console.log(\`âœ… Full backup completed: ${backupName}\`);  
    } catch (error) {  
      console.error('âŒ Backup failed:', error);  
      throw error;  
    }  
  }

  private async backupDatabase(backupName: string): Promise\<void\> {  
    const command \= \`pg\_dump ${process.env.DATABASE\_URL} | gzip \> backups/${backupName}-db.sql.gz\`;  
    await execAsync(command);  
  }

  private async backupStorage(backupName: string): Promise\<void\> {  
    // Backup uploaded files, images, etc.  
    // Implementation depends on storage solution  
  }

  private async backupConfiguration(backupName: string): Promise\<void\> {  
    // Backup environment variables, settings, etc.  
    const config \= {  
      timestamp: new Date().toISOString(),  
      environment: process.env.NODE\_ENV,  
      version: process.env.npm\_package\_version,  
    };  
      
    // Store configuration backup  
  }

  async restoreFromBackup(backupName: string): Promise\<void\> {  
    console.log(\`ğŸ”„ Restoring from backup: ${backupName}\`);  
      
    try {  
      await this.restoreDatabase(backupName);  
      await this.restoreStorage(backupName);  
        
      console.log(\`âœ… Restore completed: ${backupName}\`);  
    } catch (error) {  
      console.error('âŒ Restore failed:', error);  
      throw error;  
    }  
  }

  private async restoreDatabase(backupName: string): Promise\<void\> {  
    const command \= \`gunzip \-c backups/${backupName}-db.sql.gz | psql ${process.env.DATABASE\_URL}\`;  
    await execAsync(command);  
  }

  private async restoreStorage(backupName: string): Promise\<void\> {  
    // Restore files from backup  
  }  
}  
\`\`\`

\#\# Development Workflow

\#\#\# CI/CD Pipeline  
\`\`\`yaml  
\# .github/workflows/deploy.yml  
name: Deploy to Production

on:  
  push:  
    branches: \[main\]  
  pull\_request:  
    branches: \[main\]

jobs:  
  test:  
    runs-on: ubuntu-latest  
    steps:  
      \- uses: actions/checkout@v3  
        
      \- name: Setup Node.js  
        uses: actions/setup-node@v3  
        with:  
          node-version: '18'  
          cache: 'npm'  
        
      \- name: Install dependencies  
        run: npm ci  
        
      \- name: Run type check  
        run: npm run type-check  
        
      \- name: Run linting  
        run: npm run lint  
        
      \- name: Run tests  
        run: npm run test  
        
      \- name: Run E2E tests  
        run: npm run test:e2e

  build:  
    runs-on: ubuntu-latest  
    needs: test  
    steps:  
      \- uses: actions/checkout@v3  
        
      \- name: Setup Node.js  
        uses: actions/setup-node@v3  
        with:  
          node-version: '18'  
          cache: 'npm'  
        
      \- name: Install dependencies  
        run: npm ci  
        
      \- name: Build application  
        run: npm run build  
        env:  
          NEXT\_PUBLIC\_SUPABASE\_URL: ${{ secrets.NEXT\_PUBLIC\_SUPABASE\_URL }}  
          NEXT\_PUBLIC\_SUPABASE\_ANON\_KEY: ${{ secrets.NEXT\_PUBLIC\_SUPABASE\_ANON\_KEY }}

  deploy:  
    runs-on: ubuntu-latest  
    needs: \[test, build\]  
    if: github.ref \== 'refs/heads/main'  
    steps:  
      \- uses: actions/checkout@v3  
        
      \- name: Deploy to Vercel  
        uses: amondnet/vercel-action@v20  
        with:  
          vercel-token: ${{ secrets.VERCEL\_TOKEN }}  
          vercel-org-id: ${{ secrets.VERCEL\_ORG\_ID }}  
          vercel-project-id: ${{ secrets.VERCEL\_PROJECT\_ID }}  
          vercel-args: '--prod'  
\`\`\`

\#\#\# Health Checks  
\`\`\`typescript  
// app/api/health/route.ts  
import { NextResponse } from 'next/server';  
import { db } from '@repo/database';  
import { sql } from 'drizzle-orm';

export async function GET() {  
  const healthCheck \= {  
    status: 'healthy',  
    timestamp: new Date().toISOString(),  
    services: {} as Record\<string, any\>,  
  };

  try {  
    // Database health check  
    const dbStart \= Date.now();  
    await db.execute(sql\`SELECT 1\`);  
    healthCheck.services.database \= {  
      status: 'healthy',  
      responseTime: Date.now() \- dbStart,  
    };

    // Redis health check  
    const redisStart \= Date.now();  
    // Add Redis ping check  
    healthCheck.services.redis \= {  
      status: 'healthy',  
      responseTime: Date.now() \- redisStart,  
    };

    return NextResponse.json(healthCheck);  
  } catch (error) {  
    healthCheck.status \= 'unhealthy';  
    healthCheck.services.error \= error.message;  
      
    return NextResponse.json(healthCheck, { status: 500 });  
  }  
}  
\`\`\`

This comprehensive deployment and monitoring setup ensures MySetlist runs reliably in production with proper error handling, performance monitoring, and disaster recovery capabilities.  
